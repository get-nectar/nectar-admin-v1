"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pino";
exports.ids = ["vendor-chunks/pino"];
exports.modules = {

/***/ "(rsc)/./node_modules/pino/lib/caller.js":
/*!*****************************************!*\
  !*** ./node_modules/pino/lib/caller.js ***!
  \*****************************************/
/***/ ((module) => {

eval("\nfunction noOpPrepareStackTrace(_, stack) {\n    return stack;\n}\nmodule.exports = function getCallers() {\n    const originalPrepare = Error.prepareStackTrace;\n    Error.prepareStackTrace = noOpPrepareStackTrace;\n    const stack = new Error().stack;\n    Error.prepareStackTrace = originalPrepare;\n    if (!Array.isArray(stack)) {\n        return undefined;\n    }\n    const entries = stack.slice(2);\n    const fileNames = [];\n    for (const entry of entries){\n        if (!entry) {\n            continue;\n        }\n        fileNames.push(entry.getFileName());\n    }\n    return fileNames;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvY2FsbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsU0FBU0Esc0JBQXVCQyxDQUFDLEVBQUVDLEtBQUs7SUFDdEMsT0FBT0E7QUFDVDtBQUVBQyxPQUFPQyxPQUFPLEdBQUcsU0FBU0M7SUFDeEIsTUFBTUMsa0JBQWtCQyxNQUFNQyxpQkFBaUI7SUFDL0NELE1BQU1DLGlCQUFpQixHQUFHUjtJQUMxQixNQUFNRSxRQUFRLElBQUlLLFFBQVFMLEtBQUs7SUFDL0JLLE1BQU1DLGlCQUFpQixHQUFHRjtJQUUxQixJQUFJLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ1IsUUFBUTtRQUN6QixPQUFPUztJQUNUO0lBRUEsTUFBTUMsVUFBVVYsTUFBTVcsS0FBSyxDQUFDO0lBRTVCLE1BQU1DLFlBQVksRUFBRTtJQUVwQixLQUFLLE1BQU1DLFNBQVNILFFBQVM7UUFDM0IsSUFBSSxDQUFDRyxPQUFPO1lBQ1Y7UUFDRjtRQUVBRCxVQUFVRSxJQUFJLENBQUNELE1BQU1FLFdBQVc7SUFDbEM7SUFFQSxPQUFPSDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVjdGFyLWFkbWluLXYxLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2NhbGxlci5qcz9jODhlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBub09wUHJlcGFyZVN0YWNrVHJhY2UgKF8sIHN0YWNrKSB7XG4gIHJldHVybiBzdGFja1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldENhbGxlcnMgKCkge1xuICBjb25zdCBvcmlnaW5hbFByZXBhcmUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZVxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IG5vT3BQcmVwYXJlU3RhY2tUcmFjZVxuICBjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gb3JpZ2luYWxQcmVwYXJlXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0YWNrKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IGVudHJpZXMgPSBzdGFjay5zbGljZSgyKVxuXG4gIGNvbnN0IGZpbGVOYW1lcyA9IFtdXG5cbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBmaWxlTmFtZXMucHVzaChlbnRyeS5nZXRGaWxlTmFtZSgpKVxuICB9XG5cbiAgcmV0dXJuIGZpbGVOYW1lc1xufVxuIl0sIm5hbWVzIjpbIm5vT3BQcmVwYXJlU3RhY2tUcmFjZSIsIl8iLCJzdGFjayIsIm1vZHVsZSIsImV4cG9ydHMiLCJnZXRDYWxsZXJzIiwib3JpZ2luYWxQcmVwYXJlIiwiRXJyb3IiLCJwcmVwYXJlU3RhY2tUcmFjZSIsIkFycmF5IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImVudHJpZXMiLCJzbGljZSIsImZpbGVOYW1lcyIsImVudHJ5IiwicHVzaCIsImdldEZpbGVOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/constants.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/constants.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * Represents default log level values\n *\n * @enum {number}\n */ \nconst DEFAULT_LEVELS = {\n    trace: 10,\n    debug: 20,\n    info: 30,\n    warn: 40,\n    error: 50,\n    fatal: 60\n};\n/**\n * Represents sort order direction: `ascending` or `descending`\n *\n * @enum {string}\n */ const SORTING_ORDER = {\n    ASC: \"ASC\",\n    DESC: \"DESC\"\n};\nmodule.exports = {\n    DEFAULT_LEVELS,\n    SORTING_ORDER\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7QUFDRCxNQUFNQSxpQkFBaUI7SUFDckJDLE9BQU87SUFDUEMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTztJQUNQQyxPQUFPO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUMsZ0JBQWdCO0lBQ3BCQyxLQUFLO0lBQ0xDLE1BQU07QUFDUjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZlg7SUFDQU87QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25lY3Rhci1hZG1pbi12MS8uL25vZGVfbW9kdWxlcy9waW5vL2xpYi9jb25zdGFudHMuanM/ODNiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlcHJlc2VudHMgZGVmYXVsdCBsb2cgbGV2ZWwgdmFsdWVzXG4gKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgREVGQVVMVF9MRVZFTFMgPSB7XG4gIHRyYWNlOiAxMCxcbiAgZGVidWc6IDIwLFxuICBpbmZvOiAzMCxcbiAgd2FybjogNDAsXG4gIGVycm9yOiA1MCxcbiAgZmF0YWw6IDYwXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBzb3J0IG9yZGVyIGRpcmVjdGlvbjogYGFzY2VuZGluZ2Agb3IgYGRlc2NlbmRpbmdgXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgU09SVElOR19PUkRFUiA9IHtcbiAgQVNDOiAnQVNDJyxcbiAgREVTQzogJ0RFU0MnXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBERUZBVUxUX0xFVkVMUyxcbiAgU09SVElOR19PUkRFUlxufVxuIl0sIm5hbWVzIjpbIkRFRkFVTFRfTEVWRUxTIiwidHJhY2UiLCJkZWJ1ZyIsImluZm8iLCJ3YXJuIiwiZXJyb3IiLCJmYXRhbCIsIlNPUlRJTkdfT1JERVIiLCJBU0MiLCJERVNDIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/levels.js":
/*!*****************************************!*\
  !*** ./node_modules/pino/lib/levels.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/* eslint no-prototype-builtins: 0 */ const { lsCacheSym, levelValSym, useOnlyCustomLevelsSym, streamSym, formattersSym, hooksSym, levelCompSym } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/pino/lib/symbols.js\");\nconst { noop, genLog } = __webpack_require__(/*! ./tools */ \"(rsc)/./node_modules/pino/lib/tools.js\");\nconst { DEFAULT_LEVELS, SORTING_ORDER } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/pino/lib/constants.js\");\nconst levelMethods = {\n    fatal: (hook)=>{\n        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);\n        return function(...args) {\n            const stream = this[streamSym];\n            logFatal.call(this, ...args);\n            if (typeof stream.flushSync === \"function\") {\n                try {\n                    stream.flushSync();\n                } catch (e) {\n                // https://github.com/pinojs/pino/pull/740#discussion_r346788313\n                }\n            }\n        };\n    },\n    error: (hook)=>genLog(DEFAULT_LEVELS.error, hook),\n    warn: (hook)=>genLog(DEFAULT_LEVELS.warn, hook),\n    info: (hook)=>genLog(DEFAULT_LEVELS.info, hook),\n    debug: (hook)=>genLog(DEFAULT_LEVELS.debug, hook),\n    trace: (hook)=>genLog(DEFAULT_LEVELS.trace, hook)\n};\nconst nums = Object.keys(DEFAULT_LEVELS).reduce((o, k)=>{\n    o[DEFAULT_LEVELS[k]] = k;\n    return o;\n}, {});\nconst initialLsCache = Object.keys(nums).reduce((o, k)=>{\n    o[k] = '{\"level\":' + Number(k);\n    return o;\n}, {});\nfunction genLsCache(instance) {\n    const formatter = instance[formattersSym].level;\n    const { labels } = instance.levels;\n    const cache = {};\n    for(const label in labels){\n        const level = formatter(labels[label], Number(label));\n        cache[label] = JSON.stringify(level).slice(0, -1);\n    }\n    instance[lsCacheSym] = cache;\n    return instance;\n}\nfunction isStandardLevel(level, useOnlyCustomLevels) {\n    if (useOnlyCustomLevels) {\n        return false;\n    }\n    switch(level){\n        case \"fatal\":\n        case \"error\":\n        case \"warn\":\n        case \"info\":\n        case \"debug\":\n        case \"trace\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction setLevel(level) {\n    const { labels, values } = this.levels;\n    if (typeof level === \"number\") {\n        if (labels[level] === undefined) throw Error(\"unknown level value\" + level);\n        level = labels[level];\n    }\n    if (values[level] === undefined) throw Error(\"unknown level \" + level);\n    const preLevelVal = this[levelValSym];\n    const levelVal = this[levelValSym] = values[level];\n    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];\n    const levelComparison = this[levelCompSym];\n    const hook = this[hooksSym].logMethod;\n    for(const key in values){\n        if (levelComparison(values[key], levelVal) === false) {\n            this[key] = noop;\n            continue;\n        }\n        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);\n    }\n    this.emit(\"level-change\", level, levelVal, labels[preLevelVal], preLevelVal, this);\n}\nfunction getLevel(level) {\n    const { levels, levelVal } = this;\n    // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)\n    return levels && levels.labels ? levels.labels[levelVal] : \"\";\n}\nfunction isLevelEnabled(logLevel) {\n    const { values } = this.levels;\n    const logLevelVal = values[logLevel];\n    return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym]);\n}\n/**\n * Determine if the given `current` level is enabled by comparing it\n * against the current threshold (`expected`).\n *\n * @param {SORTING_ORDER} direction comparison direction \"ASC\" or \"DESC\"\n * @param {number} current current log level number representation\n * @param {number} expected threshold value to compare with\n * @returns {boolean}\n */ function compareLevel(direction, current, expected) {\n    if (direction === SORTING_ORDER.DESC) {\n        return current <= expected;\n    }\n    return current >= expected;\n}\n/**\n * Create a level comparison function based on `levelComparison`\n * it could a default function which compares levels either in \"ascending\" or \"descending\" order or custom comparison function\n *\n * @param {SORTING_ORDER | Function} levelComparison sort levels order direction or custom comparison function\n * @returns Function\n */ function genLevelComparison(levelComparison) {\n    if (typeof levelComparison === \"string\") {\n        return compareLevel.bind(null, levelComparison);\n    }\n    return levelComparison;\n}\nfunction mappings(customLevels = null, useOnlyCustomLevels = false) {\n    const customNums = customLevels ? Object.keys(customLevels).reduce((o, k)=>{\n        o[customLevels[k]] = k;\n        return o;\n    }, {}) : null;\n    /* eslint-enable */ const labels = Object.assign(Object.create(Object.prototype, {\n        Infinity: {\n            value: \"silent\"\n        }\n    }), useOnlyCustomLevels ? null : nums, customNums);\n    const values = Object.assign(Object.create(Object.prototype, {\n        silent: {\n            value: Infinity\n        }\n    }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);\n    return {\n        labels,\n        values\n    };\n}\nfunction assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {\n    if (typeof defaultLevel === \"number\") {\n        const values = [].concat(Object.keys(customLevels || {}).map((key)=>customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level)=>+level), Infinity);\n        if (!values.includes(defaultLevel)) {\n            throw Error(`default level:${defaultLevel} must be included in custom levels`);\n        }\n        return;\n    }\n    const labels = Object.assign(Object.create(Object.prototype, {\n        silent: {\n            value: Infinity\n        }\n    }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);\n    if (!(defaultLevel in labels)) {\n        throw Error(`default level:${defaultLevel} must be included in custom levels`);\n    }\n}\nfunction assertNoLevelCollisions(levels, customLevels) {\n    const { labels, values } = levels;\n    for(const k in customLevels){\n        if (k in values) {\n            throw Error(\"levels cannot be overridden\");\n        }\n        if (customLevels[k] in labels) {\n            throw Error(\"pre-existing level values cannot be used for new levels\");\n        }\n    }\n}\n/**\n * Validates whether `levelComparison` is correct\n *\n * @throws Error\n * @param {SORTING_ORDER | Function} levelComparison - value to validate\n * @returns\n */ function assertLevelComparison(levelComparison) {\n    if (typeof levelComparison === \"function\") {\n        return;\n    }\n    if (typeof levelComparison === \"string\" && Object.values(SORTING_ORDER).includes(levelComparison)) {\n        return;\n    }\n    throw new Error('Levels comparison should be one of \"ASC\", \"DESC\" or \"function\" type');\n}\nmodule.exports = {\n    initialLsCache,\n    genLsCache,\n    levelMethods,\n    getLevel,\n    setLevel,\n    isLevelEnabled,\n    mappings,\n    assertNoLevelCollisions,\n    assertDefaultLevelFound,\n    genLevelComparison,\n    assertLevelComparison\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbGV2ZWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsbUNBQW1DLEdBQ25DLE1BQU0sRUFDSkEsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLHNCQUFzQixFQUN0QkMsU0FBUyxFQUNUQyxhQUFhLEVBQ2JDLFFBQVEsRUFDUkMsWUFBWSxFQUNiLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNqQyxNQUFNLEVBQUVHLGNBQWMsRUFBRUMsYUFBYSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBRWxELE1BQU1LLGVBQWU7SUFDbkJDLE9BQU8sQ0FBQ0M7UUFDTixNQUFNQyxXQUFXTixPQUFPQyxlQUFlRyxLQUFLLEVBQUVDO1FBQzlDLE9BQU8sU0FBVSxHQUFHRSxJQUFJO1lBQ3RCLE1BQU1DLFNBQVMsSUFBSSxDQUFDZCxVQUFVO1lBQzlCWSxTQUFTRyxJQUFJLENBQUMsSUFBSSxLQUFLRjtZQUN2QixJQUFJLE9BQU9DLE9BQU9FLFNBQVMsS0FBSyxZQUFZO2dCQUMxQyxJQUFJO29CQUNGRixPQUFPRSxTQUFTO2dCQUNsQixFQUFFLE9BQU9DLEdBQUc7Z0JBQ1YsZ0VBQWdFO2dCQUNsRTtZQUNGO1FBQ0Y7SUFDRjtJQUNBQyxPQUFPLENBQUNQLE9BQVNMLE9BQU9DLGVBQWVXLEtBQUssRUFBRVA7SUFDOUNRLE1BQU0sQ0FBQ1IsT0FBU0wsT0FBT0MsZUFBZVksSUFBSSxFQUFFUjtJQUM1Q1MsTUFBTSxDQUFDVCxPQUFTTCxPQUFPQyxlQUFlYSxJQUFJLEVBQUVUO0lBQzVDVSxPQUFPLENBQUNWLE9BQVNMLE9BQU9DLGVBQWVjLEtBQUssRUFBRVY7SUFDOUNXLE9BQU8sQ0FBQ1gsT0FBU0wsT0FBT0MsZUFBZWUsS0FBSyxFQUFFWDtBQUNoRDtBQUVBLE1BQU1ZLE9BQU9DLE9BQU9DLElBQUksQ0FBQ2xCLGdCQUFnQm1CLE1BQU0s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RUEsSUFBSSxPQUFPQSxvQkFBb0IsWUFBWTNCLE9BQU9xQixNQUFNLENBQUNyQyxlQUFldUUsUUFBUSxDQUFDNUIsa0JBQWtCO1FBQ2pHO0lBQ0Y7SUFFQSxNQUFNLElBQUlKLE1BQU07QUFDbEI7QUFFQW1DLE9BQU9DLE9BQU8sR0FBRztJQUNmdEQ7SUFDQUU7SUFDQXRCO0lBQ0E4QztJQUNBWDtJQUNBWTtJQUNBVTtJQUNBYztJQUNBTDtJQUNBWDtJQUNBaUI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25lY3Rhci1hZG1pbi12MS8uL25vZGVfbW9kdWxlcy9waW5vL2xpYi9sZXZlbHMuanM/NWQ1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8qIGVzbGludCBuby1wcm90b3R5cGUtYnVpbHRpbnM6IDAgKi9cbmNvbnN0IHtcbiAgbHNDYWNoZVN5bSxcbiAgbGV2ZWxWYWxTeW0sXG4gIHVzZU9ubHlDdXN0b21MZXZlbHNTeW0sXG4gIHN0cmVhbVN5bSxcbiAgZm9ybWF0dGVyc1N5bSxcbiAgaG9va3NTeW0sXG4gIGxldmVsQ29tcFN5bVxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IG5vb3AsIGdlbkxvZyB9ID0gcmVxdWlyZSgnLi90b29scycpXG5jb25zdCB7IERFRkFVTFRfTEVWRUxTLCBTT1JUSU5HX09SREVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmNvbnN0IGxldmVsTWV0aG9kcyA9IHtcbiAgZmF0YWw6IChob29rKSA9PiB7XG4gICAgY29uc3QgbG9nRmF0YWwgPSBnZW5Mb2coREVGQVVMVF9MRVZFTFMuZmF0YWwsIGhvb2spXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSB0aGlzW3N0cmVhbVN5bV1cbiAgICAgIGxvZ0ZhdGFsLmNhbGwodGhpcywgLi4uYXJncylcbiAgICAgIGlmICh0eXBlb2Ygc3RyZWFtLmZsdXNoU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0cmVhbS5mbHVzaFN5bmMoKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9waW5vL3B1bGwvNzQwI2Rpc2N1c3Npb25fcjM0Njc4ODMxM1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogKGhvb2spID0+IGdlbkxvZyhERUZBVUxUX0xFVkVMUy5lcnJvciwgaG9vayksXG4gIHdhcm46IChob29rKSA9PiBnZW5Mb2coREVGQVVMVF9MRVZFTFMud2FybiwgaG9vayksXG4gIGluZm86IChob29rKSA9PiBnZW5Mb2coREVGQVVMVF9MRVZFTFMuaW5mbywgaG9vayksXG4gIGRlYnVnOiAoaG9vaykgPT4gZ2VuTG9nKERFRkFVTFRfTEVWRUxTLmRlYnVnLCBob29rKSxcbiAgdHJhY2U6IChob29rKSA9PiBnZW5Mb2coREVGQVVMVF9MRVZFTFMudHJhY2UsIGhvb2spXG59XG5cbmNvbnN0IG51bXMgPSBPYmplY3Qua2V5cyhERUZBVUxUX0xFVkVMUykucmVkdWNlKChvLCBrKSA9PiB7XG4gIG9bREVGQVVMVF9MRVZFTFNba11dID0ga1xuICByZXR1cm4gb1xufSwge30pXG5cbmNvbnN0IGluaXRpYWxMc0NhY2hlID0gT2JqZWN0LmtleXMobnVtcykucmVkdWNlKChvLCBrKSA9PiB7XG4gIG9ba10gPSAne1wibGV2ZWxcIjonICsgTnVtYmVyKGspXG4gIHJldHVybiBvXG59LCB7fSlcblxuZnVuY3Rpb24gZ2VuTHNDYWNoZSAoaW5zdGFuY2UpIHtcbiAgY29uc3QgZm9ybWF0dGVyID0gaW5zdGFuY2VbZm9ybWF0dGVyc1N5bV0ubGV2ZWxcbiAgY29uc3QgeyBsYWJlbHMgfSA9IGluc3RhbmNlLmxldmVsc1xuICBjb25zdCBjYWNoZSA9IHt9XG4gIGZvciAoY29uc3QgbGFiZWwgaW4gbGFiZWxzKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBmb3JtYXR0ZXIobGFiZWxzW2xhYmVsXSwgTnVtYmVyKGxhYmVsKSlcbiAgICBjYWNoZVtsYWJlbF0gPSBKU09OLnN0cmluZ2lmeShsZXZlbCkuc2xpY2UoMCwgLTEpXG4gIH1cbiAgaW5zdGFuY2VbbHNDYWNoZVN5bV0gPSBjYWNoZVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxuZnVuY3Rpb24gaXNTdGFuZGFyZExldmVsIChsZXZlbCwgdXNlT25seUN1c3RvbUxldmVscykge1xuICBpZiAodXNlT25seUN1c3RvbUxldmVscykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgJ2ZhdGFsJzpcbiAgICBjYXNlICdlcnJvcic6XG4gICAgY2FzZSAnd2Fybic6XG4gICAgY2FzZSAnaW5mbyc6XG4gICAgY2FzZSAnZGVidWcnOlxuICAgIGNhc2UgJ3RyYWNlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldExldmVsIChsZXZlbCkge1xuICBjb25zdCB7IGxhYmVscywgdmFsdWVzIH0gPSB0aGlzLmxldmVsc1xuICBpZiAodHlwZW9mIGxldmVsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChsYWJlbHNbbGV2ZWxdID09PSB1bmRlZmluZWQpIHRocm93IEVycm9yKCd1bmtub3duIGxldmVsIHZhbHVlJyArIGxldmVsKVxuICAgIGxldmVsID0gbGFiZWxzW2xldmVsXVxuICB9XG4gIGlmICh2YWx1ZXNbbGV2ZWxdID09PSB1bmRlZmluZWQpIHRocm93IEVycm9yKCd1bmtub3duIGxldmVsICcgKyBsZXZlbClcbiAgY29uc3QgcHJlTGV2ZWxWYWwgPSB0aGlzW2xldmVsVmFsU3ltXVxuICBjb25zdCBsZXZlbFZhbCA9IHRoaXNbbGV2ZWxWYWxTeW1dID0gdmFsdWVzW2xldmVsXVxuICBjb25zdCB1c2VPbmx5Q3VzdG9tTGV2ZWxzVmFsID0gdGhpc1t1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltXVxuICBjb25zdCBsZXZlbENvbXBhcmlzb24gPSB0aGlzW2xldmVsQ29tcFN5bV1cbiAgY29uc3QgaG9vayA9IHRoaXNbaG9va3NTeW1dLmxvZ01ldGhvZFxuXG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuICAgIGlmIChsZXZlbENvbXBhcmlzb24odmFsdWVzW2tleV0sIGxldmVsVmFsKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXNba2V5XSA9IG5vb3BcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHRoaXNba2V5XSA9IGlzU3RhbmRhcmRMZXZlbChrZXksIHVzZU9ubHlDdXN0b21MZXZlbHNWYWwpID8gbGV2ZWxNZXRob2RzW2tleV0oaG9vaykgOiBnZW5Mb2codmFsdWVzW2tleV0sIGhvb2spXG4gIH1cblxuICB0aGlzLmVtaXQoXG4gICAgJ2xldmVsLWNoYW5nZScsXG4gICAgbGV2ZWwsXG4gICAgbGV2ZWxWYWwsXG4gICAgbGFiZWxzW3ByZUxldmVsVmFsXSxcbiAgICBwcmVMZXZlbFZhbCxcbiAgICB0aGlzXG4gIClcbn1cblxuZnVuY3Rpb24gZ2V0TGV2ZWwgKGxldmVsKSB7XG4gIGNvbnN0IHsgbGV2ZWxzLCBsZXZlbFZhbCB9ID0gdGhpc1xuICAvLyBwcm90ZWN0aW9uIGFnYWluc3QgcG90ZW50aWFsIGxvc3Mgb2YgUGlubyBzY29wZSBmcm9tIHNlcmlhbGl6ZXJzIChlZGdlIGNhc2Ugd2l0aCBjaXJjdWxhciByZWZzIC0gaHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9waW5vL2lzc3Vlcy84MzMpXG4gIHJldHVybiAobGV2ZWxzICYmIGxldmVscy5sYWJlbHMpID8gbGV2ZWxzLmxhYmVsc1tsZXZlbFZhbF0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc0xldmVsRW5hYmxlZCAobG9nTGV2ZWwpIHtcbiAgY29uc3QgeyB2YWx1ZXMgfSA9IHRoaXMubGV2ZWxzXG4gIGNvbnN0IGxvZ0xldmVsVmFsID0gdmFsdWVzW2xvZ0xldmVsXVxuICByZXR1cm4gbG9nTGV2ZWxWYWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzW2xldmVsQ29tcFN5bV0obG9nTGV2ZWxWYWwsIHRoaXNbbGV2ZWxWYWxTeW1dKVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gYGN1cnJlbnRgIGxldmVsIGlzIGVuYWJsZWQgYnkgY29tcGFyaW5nIGl0XG4gKiBhZ2FpbnN0IHRoZSBjdXJyZW50IHRocmVzaG9sZCAoYGV4cGVjdGVkYCkuXG4gKlxuICogQHBhcmFtIHtTT1JUSU5HX09SREVSfSBkaXJlY3Rpb24gY29tcGFyaXNvbiBkaXJlY3Rpb24gXCJBU0NcIiBvciBcIkRFU0NcIlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnQgY3VycmVudCBsb2cgbGV2ZWwgbnVtYmVyIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWQgdGhyZXNob2xkIHZhbHVlIHRvIGNvbXBhcmUgd2l0aFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVMZXZlbCAoZGlyZWN0aW9uLCBjdXJyZW50LCBleHBlY3RlZCkge1xuICBpZiAoZGlyZWN0aW9uID09PSBTT1JUSU5HX09SREVSLkRFU0MpIHtcbiAgICByZXR1cm4gY3VycmVudCA8PSBleHBlY3RlZFxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnQgPj0gZXhwZWN0ZWRcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBsZXZlbCBjb21wYXJpc29uIGZ1bmN0aW9uIGJhc2VkIG9uIGBsZXZlbENvbXBhcmlzb25gXG4gKiBpdCBjb3VsZCBhIGRlZmF1bHQgZnVuY3Rpb24gd2hpY2ggY29tcGFyZXMgbGV2ZWxzIGVpdGhlciBpbiBcImFzY2VuZGluZ1wiIG9yIFwiZGVzY2VuZGluZ1wiIG9yZGVyIG9yIGN1c3RvbSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtTT1JUSU5HX09SREVSIHwgRnVuY3Rpb259IGxldmVsQ29tcGFyaXNvbiBzb3J0IGxldmVscyBvcmRlciBkaXJlY3Rpb24gb3IgY3VzdG9tIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAqIEByZXR1cm5zIEZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdlbkxldmVsQ29tcGFyaXNvbiAobGV2ZWxDb21wYXJpc29uKSB7XG4gIGlmICh0eXBlb2YgbGV2ZWxDb21wYXJpc29uID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb21wYXJlTGV2ZWwuYmluZChudWxsLCBsZXZlbENvbXBhcmlzb24pXG4gIH1cblxuICByZXR1cm4gbGV2ZWxDb21wYXJpc29uXG59XG5cbmZ1bmN0aW9uIG1hcHBpbmdzIChjdXN0b21MZXZlbHMgPSBudWxsLCB1c2VPbmx5Q3VzdG9tTGV2ZWxzID0gZmFsc2UpIHtcbiAgY29uc3QgY3VzdG9tTnVtcyA9IGN1c3RvbUxldmVsc1xuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgPyBPYmplY3Qua2V5cyhjdXN0b21MZXZlbHMpLnJlZHVjZSgobywgaykgPT4ge1xuICAgICAgICBvW2N1c3RvbUxldmVsc1trXV0gPSBrXG4gICAgICAgIHJldHVybiBvXG4gICAgICB9LCB7fSlcbiAgICA6IG51bGxcbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmFzc2lnbihcbiAgICBPYmplY3QuY3JlYXRlKE9iamVjdC5wcm90b3R5cGUsIHsgSW5maW5pdHk6IHsgdmFsdWU6ICdzaWxlbnQnIH0gfSksXG4gICAgdXNlT25seUN1c3RvbUxldmVscyA/IG51bGwgOiBudW1zLFxuICAgIGN1c3RvbU51bXNcbiAgKVxuICBjb25zdCB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKFxuICAgIE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwgeyBzaWxlbnQ6IHsgdmFsdWU6IEluZmluaXR5IH0gfSksXG4gICAgdXNlT25seUN1c3RvbUxldmVscyA/IG51bGwgOiBERUZBVUxUX0xFVkVMUyxcbiAgICBjdXN0b21MZXZlbHNcbiAgKVxuICByZXR1cm4geyBsYWJlbHMsIHZhbHVlcyB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlZmF1bHRMZXZlbEZvdW5kIChkZWZhdWx0TGV2ZWwsIGN1c3RvbUxldmVscywgdXNlT25seUN1c3RvbUxldmVscykge1xuICBpZiAodHlwZW9mIGRlZmF1bHRMZXZlbCA9PT0gJ251bWJlcicpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5jb25jYXQoXG4gICAgICBPYmplY3Qua2V5cyhjdXN0b21MZXZlbHMgfHwge30pLm1hcChrZXkgPT4gY3VzdG9tTGV2ZWxzW2tleV0pLFxuICAgICAgdXNlT25seUN1c3RvbUxldmVscyA/IFtdIDogT2JqZWN0LmtleXMobnVtcykubWFwKGxldmVsID0+ICtsZXZlbCksXG4gICAgICBJbmZpbml0eVxuICAgIClcbiAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyhkZWZhdWx0TGV2ZWwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZGVmYXVsdCBsZXZlbDoke2RlZmF1bHRMZXZlbH0gbXVzdCBiZSBpbmNsdWRlZCBpbiBjdXN0b20gbGV2ZWxzYClcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBsYWJlbHMgPSBPYmplY3QuYXNzaWduKFxuICAgIE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwgeyBzaWxlbnQ6IHsgdmFsdWU6IEluZmluaXR5IH0gfSksXG4gICAgdXNlT25seUN1c3RvbUxldmVscyA/IG51bGwgOiBERUZBVUxUX0xFVkVMUyxcbiAgICBjdXN0b21MZXZlbHNcbiAgKVxuICBpZiAoIShkZWZhdWx0TGV2ZWwgaW4gbGFiZWxzKSkge1xuICAgIHRocm93IEVycm9yKGBkZWZhdWx0IGxldmVsOiR7ZGVmYXVsdExldmVsfSBtdXN0IGJlIGluY2x1ZGVkIGluIGN1c3RvbSBsZXZlbHNgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5vTGV2ZWxDb2xsaXNpb25zIChsZXZlbHMsIGN1c3RvbUxldmVscykge1xuICBjb25zdCB7IGxhYmVscywgdmFsdWVzIH0gPSBsZXZlbHNcbiAgZm9yIChjb25zdCBrIGluIGN1c3RvbUxldmVscykge1xuICAgIGlmIChrIGluIHZhbHVlcykge1xuICAgICAgdGhyb3cgRXJyb3IoJ2xldmVscyBjYW5ub3QgYmUgb3ZlcnJpZGRlbicpXG4gICAgfVxuICAgIGlmIChjdXN0b21MZXZlbHNba10gaW4gbGFiZWxzKSB7XG4gICAgICB0aHJvdyBFcnJvcigncHJlLWV4aXN0aW5nIGxldmVsIHZhbHVlcyBjYW5ub3QgYmUgdXNlZCBmb3IgbmV3IGxldmVscycpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgYGxldmVsQ29tcGFyaXNvbmAgaXMgY29ycmVjdFxuICpcbiAqIEB0aHJvd3MgRXJyb3JcbiAqIEBwYXJhbSB7U09SVElOR19PUkRFUiB8IEZ1bmN0aW9ufSBsZXZlbENvbXBhcmlzb24gLSB2YWx1ZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0TGV2ZWxDb21wYXJpc29uIChsZXZlbENvbXBhcmlzb24pIHtcbiAgaWYgKHR5cGVvZiBsZXZlbENvbXBhcmlzb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0eXBlb2YgbGV2ZWxDb21wYXJpc29uID09PSAnc3RyaW5nJyAmJiBPYmplY3QudmFsdWVzKFNPUlRJTkdfT1JERVIpLmluY2x1ZGVzKGxldmVsQ29tcGFyaXNvbikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignTGV2ZWxzIGNvbXBhcmlzb24gc2hvdWxkIGJlIG9uZSBvZiBcIkFTQ1wiLCBcIkRFU0NcIiBvciBcImZ1bmN0aW9uXCIgdHlwZScpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0aWFsTHNDYWNoZSxcbiAgZ2VuTHNDYWNoZSxcbiAgbGV2ZWxNZXRob2RzLFxuICBnZXRMZXZlbCxcbiAgc2V0TGV2ZWwsXG4gIGlzTGV2ZWxFbmFibGVkLFxuICBtYXBwaW5ncyxcbiAgYXNzZXJ0Tm9MZXZlbENvbGxpc2lvbnMsXG4gIGFzc2VydERlZmF1bHRMZXZlbEZvdW5kLFxuICBnZW5MZXZlbENvbXBhcmlzb24sXG4gIGFzc2VydExldmVsQ29tcGFyaXNvblxufVxuIl0sIm5hbWVzIjpbImxzQ2FjaGVTeW0iLCJsZXZlbFZhbFN5bSIsInVzZU9ubHlDdXN0b21MZXZlbHNTeW0iLCJzdHJlYW1TeW0iLCJmb3JtYXR0ZXJzU3ltIiwiaG9va3NTeW0iLCJsZXZlbENvbXBTeW0iLCJyZXF1aXJlIiwibm9vcCIsImdlbkxvZyIsIkRFRkFVTFRfTEVWRUxTIiwiU09SVElOR19PUkRFUiIsImxldmVsTWV0aG9kcyIsImZhdGFsIiwiaG9vayIsImxvZ0ZhdGFsIiwiYXJncyIsInN0cmVhbSIsImNhbGwiLCJmbHVzaFN5bmMiLCJlIiwiZXJyb3IiLCJ3YXJuIiwiaW5mbyIsImRlYnVnIiwidHJhY2UiLCJudW1zIiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsIm8iLCJrIiwiaW5pdGlhbExzQ2FjaGUiLCJOdW1iZXIiLCJnZW5Mc0NhY2hlIiwiaW5zdGFuY2UiLCJmb3JtYXR0ZXIiLCJsZXZlbCIsImxhYmVscyIsImxldmVscyIsImNhY2hlIiwibGFiZWwiLCJKU09OIiwic3RyaW5naWZ5Iiwic2xpY2UiLCJpc1N0YW5kYXJkTGV2ZWwiLCJ1c2VPbmx5Q3VzdG9tTGV2ZWxzIiwic2V0TGV2ZWwiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJFcnJvciIsInByZUxldmVsVmFsIiwibGV2ZWxWYWwiLCJ1c2VPbmx5Q3VzdG9tTGV2ZWxzVmFsIiwibGV2ZWxDb21wYXJpc29uIiwibG9nTWV0aG9kIiwia2V5IiwiZW1pdCIsImdldExldmVsIiwiaXNMZXZlbEVuYWJsZWQiLCJsb2dMZXZlbCIsImxvZ0xldmVsVmFsIiwiY29tcGFyZUxldmVsIiwiZGlyZWN0aW9uIiwiY3VycmVudCIsImV4cGVjdGVkIiwiREVTQyIsImdlbkxldmVsQ29tcGFyaXNvbiIsImJpbmQiLCJtYXBwaW5ncyIsImN1c3RvbUxldmVscyIsImN1c3RvbU51bXMiLCJhc3NpZ24iLCJjcmVhdGUiLCJwcm90b3R5cGUiLCJJbmZpbml0eSIsInZhbHVlIiwic2lsZW50IiwiYXNzZXJ0RGVmYXVsdExldmVsRm91bmQiLCJkZWZhdWx0TGV2ZWwiLCJjb25jYXQiLCJtYXAiLCJpbmNsdWRlcyIsImFzc2VydE5vTGV2ZWxDb2xsaXNpb25zIiwiYXNzZXJ0TGV2ZWxDb21wYXJpc29uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/levels.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/meta.js":
/*!***************************************!*\
  !*** ./node_modules/pino/lib/meta.js ***!
  \***************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    version: \"8.21.0\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbWV0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFBRUMsU0FBUztBQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVjdGFyLWFkbWluLXYxLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL21ldGEuanM/MjE5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICc4LjIxLjAnIH1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/meta.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/multistream.js":
/*!**********************************************!*\
  !*** ./node_modules/pino/lib/multistream.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst metadata = Symbol.for(\"pino.metadata\");\nconst { DEFAULT_LEVELS } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/pino/lib/constants.js\");\nconst DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;\nfunction multistream(streamsArray, opts) {\n    let counter = 0;\n    streamsArray = streamsArray || [];\n    opts = opts || {\n        dedupe: false\n    };\n    const streamLevels = Object.create(DEFAULT_LEVELS);\n    streamLevels.silent = Infinity;\n    if (opts.levels && typeof opts.levels === \"object\") {\n        Object.keys(opts.levels).forEach((i)=>{\n            streamLevels[i] = opts.levels[i];\n        });\n    }\n    const res = {\n        write,\n        add,\n        emit,\n        flushSync,\n        end,\n        minLevel: 0,\n        streams: [],\n        clone,\n        [metadata]: true,\n        streamLevels\n    };\n    if (Array.isArray(streamsArray)) {\n        streamsArray.forEach(add, res);\n    } else {\n        add.call(res, streamsArray);\n    }\n    // clean this object up\n    // or it will stay allocated forever\n    // as it is closed on the following closures\n    streamsArray = null;\n    return res;\n    // we can exit early because the streams are ordered by level\n    function write(data) {\n        let dest;\n        const level = this.lastLevel;\n        const { streams } = this;\n        // for handling situation when several streams has the same level\n        let recordedLevel = 0;\n        let stream;\n        // if dedupe set to true we send logs to the stream with the highest level\n        // therefore, we have to change sorting order\n        for(let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)){\n            dest = streams[i];\n            if (dest.level <= level) {\n                if (recordedLevel !== 0 && recordedLevel !== dest.level) {\n                    break;\n                }\n                stream = dest.stream;\n                if (stream[metadata]) {\n                    const { lastTime, lastMsg, lastObj, lastLogger } = this;\n                    stream.lastLevel = level;\n                    stream.lastTime = lastTime;\n                    stream.lastMsg = lastMsg;\n                    stream.lastObj = lastObj;\n                    stream.lastLogger = lastLogger;\n                }\n                stream.write(data);\n                if (opts.dedupe) {\n                    recordedLevel = dest.level;\n                }\n            } else if (!opts.dedupe) {\n                break;\n            }\n        }\n    }\n    function emit(...args) {\n        for (const { stream } of this.streams){\n            if (typeof stream.emit === \"function\") {\n                stream.emit(...args);\n            }\n        }\n    }\n    function flushSync() {\n        for (const { stream } of this.streams){\n            if (typeof stream.flushSync === \"function\") {\n                stream.flushSync();\n            }\n        }\n    }\n    function add(dest) {\n        if (!dest) {\n            return res;\n        }\n        // Check that dest implements either StreamEntry or DestinationStream\n        const isStream = typeof dest.write === \"function\" || dest.stream;\n        const stream_ = dest.write ? dest : dest.stream;\n        // This is necessary to provide a meaningful error message, otherwise it throws somewhere inside write()\n        if (!isStream) {\n            throw Error(\"stream object needs to implement either StreamEntry or DestinationStream interface\");\n        }\n        const { streams, streamLevels } = this;\n        let level;\n        if (typeof dest.levelVal === \"number\") {\n            level = dest.levelVal;\n        } else if (typeof dest.level === \"string\") {\n            level = streamLevels[dest.level];\n        } else if (typeof dest.level === \"number\") {\n            level = dest.level;\n        } else {\n            level = DEFAULT_INFO_LEVEL;\n        }\n        const dest_ = {\n            stream: stream_,\n            level,\n            levelVal: undefined,\n            id: counter++\n        };\n        streams.unshift(dest_);\n        streams.sort(compareByLevel);\n        this.minLevel = streams[0].level;\n        return res;\n    }\n    function end() {\n        for (const { stream } of this.streams){\n            if (typeof stream.flushSync === \"function\") {\n                stream.flushSync();\n            }\n            stream.end();\n        }\n    }\n    function clone(level) {\n        const streams = new Array(this.streams.length);\n        for(let i = 0; i < streams.length; i++){\n            streams[i] = {\n                level,\n                stream: this.streams[i].stream\n            };\n        }\n        return {\n            write,\n            add,\n            minLevel: level,\n            streams,\n            clone,\n            emit,\n            flushSync,\n            [metadata]: true\n        };\n    }\n}\nfunction compareByLevel(a, b) {\n    return a.level - b.level;\n}\nfunction initLoopVar(length, dedupe) {\n    return dedupe ? length - 1 : 0;\n}\nfunction adjustLoopVar(i, dedupe) {\n    return dedupe ? i - 1 : i + 1;\n}\nfunction checkLoopVar(i, length, dedupe) {\n    return dedupe ? i >= 0 : i < length;\n}\nmodule.exports = multistream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbXVsdGlzdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxXQUFXQyxPQUFPQyxHQUFHLENBQUM7QUFDNUIsTUFBTSxFQUFFQyxjQUFjLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFbkMsTUFBTUMscUJBQXFCRixlQUFlRyxJQUFJO0FBRTlDLFNBQVNDLFlBQWFDLFlBQVksRUFBRUMsSUFBSTtJQUN0QyxJQUFJQyxVQUFVO0lBQ2RGLGVBQWVBLGdCQUFnQixFQUFFO0lBQ2pDQyxPQUFPQSxRQUFRO1FBQUVFLFFBQVE7SUFBTTtJQUUvQixNQUFNQyxlQUFlQyxPQUFPQyxNQUFNLENBQUNYO0lBQ25DUyxhQUFhRyxNQUFNLEdBQUdDO0lBQ3RCLElBQUlQLEtBQUtRLE1BQU0sSUFBSSxPQUFPUixLQUFLUSxNQUFNLEtBQUssVUFBVTtRQUNsREosT0FBT0ssSUFBSSxDQUFDVCxLQUFLUSxNQUFNLEVBQUVFLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDL0JSLFlBQVksQ0FBQ1EsRUFBRSxHQUFHWCxLQUFLUSxNQUFNLENBQUNHLEVBQUU7UUFDbEM7SUFDRjtJQUVBLE1BQU1DLE1BQU07UUFDVkM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUMsVUFBVTtRQUNWQyxTQUFTLEVBQUU7UUFDWEM7UUFDQSxDQUFDN0IsU0FBUyxFQUFFO1FBQ1pZO0lBQ0Y7SUFFQSxJQUFJa0IsTUFBTUMsT0FBTyxDQUFDdkIsZUFBZTtRQUMvQkEsYUFBYVcsT0FBTyxDQUFDSSxLQUFLRjtJQUM1QixPQUFPO1FBQ0xFLElBQUlTLElBQUksQ0FBQ1gsS0FBS2I7SUFDaEI7SUFFQSx1QkFBdUI7SUFDdkIsb0NBQW9DO0lBQ3BDLDRDQUE0QztJQUM1Q0EsZUFBZTtJQUVmLE9BQU9hO0lBRVAsNkRBQTZEO0lBQzdELFNBQVNDLE1BQU9XLElBQUk7UUFDbEIsSUFBSUM7UUFDSixNQUFNQyxRQUFRLElBQUksQ0FBQ0MsU0FBUztR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MS8uL25vZGVfbW9kdWxlcy9waW5vL2xpYi9tdWx0aXN0cmVhbS5qcz8xZDUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtZXRhZGF0YSA9IFN5bWJvbC5mb3IoJ3Bpbm8ubWV0YWRhdGEnKVxuY29uc3QgeyBERUZBVUxUX0xFVkVMUyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG5jb25zdCBERUZBVUxUX0lORk9fTEVWRUwgPSBERUZBVUxUX0xFVkVMUy5pbmZvXG5cbmZ1bmN0aW9uIG11bHRpc3RyZWFtIChzdHJlYW1zQXJyYXksIG9wdHMpIHtcbiAgbGV0IGNvdW50ZXIgPSAwXG4gIHN0cmVhbXNBcnJheSA9IHN0cmVhbXNBcnJheSB8fCBbXVxuICBvcHRzID0gb3B0cyB8fCB7IGRlZHVwZTogZmFsc2UgfVxuXG4gIGNvbnN0IHN0cmVhbUxldmVscyA9IE9iamVjdC5jcmVhdGUoREVGQVVMVF9MRVZFTFMpXG4gIHN0cmVhbUxldmVscy5zaWxlbnQgPSBJbmZpbml0eVxuICBpZiAob3B0cy5sZXZlbHMgJiYgdHlwZW9mIG9wdHMubGV2ZWxzID09PSAnb2JqZWN0Jykge1xuICAgIE9iamVjdC5rZXlzKG9wdHMubGV2ZWxzKS5mb3JFYWNoKGkgPT4ge1xuICAgICAgc3RyZWFtTGV2ZWxzW2ldID0gb3B0cy5sZXZlbHNbaV1cbiAgICB9KVxuICB9XG5cbiAgY29uc3QgcmVzID0ge1xuICAgIHdyaXRlLFxuICAgIGFkZCxcbiAgICBlbWl0LFxuICAgIGZsdXNoU3luYyxcbiAgICBlbmQsXG4gICAgbWluTGV2ZWw6IDAsXG4gICAgc3RyZWFtczogW10sXG4gICAgY2xvbmUsXG4gICAgW21ldGFkYXRhXTogdHJ1ZSxcbiAgICBzdHJlYW1MZXZlbHNcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNBcnJheSkpIHtcbiAgICBzdHJlYW1zQXJyYXkuZm9yRWFjaChhZGQsIHJlcylcbiAgfSBlbHNlIHtcbiAgICBhZGQuY2FsbChyZXMsIHN0cmVhbXNBcnJheSlcbiAgfVxuXG4gIC8vIGNsZWFuIHRoaXMgb2JqZWN0IHVwXG4gIC8vIG9yIGl0IHdpbGwgc3RheSBhbGxvY2F0ZWQgZm9yZXZlclxuICAvLyBhcyBpdCBpcyBjbG9zZWQgb24gdGhlIGZvbGxvd2luZyBjbG9zdXJlc1xuICBzdHJlYW1zQXJyYXkgPSBudWxsXG5cbiAgcmV0dXJuIHJlc1xuXG4gIC8vIHdlIGNhbiBleGl0IGVhcmx5IGJlY2F1c2UgdGhlIHN0cmVhbXMgYXJlIG9yZGVyZWQgYnkgbGV2ZWxcbiAgZnVuY3Rpb24gd3JpdGUgKGRhdGEpIHtcbiAgICBsZXQgZGVzdFxuICAgIGNvbnN0IGxldmVsID0gdGhpcy5sYXN0TGV2ZWxcbiAgICBjb25zdCB7IHN0cmVhbXMgfSA9IHRoaXNcbiAgICAvLyBmb3IgaGFuZGxpbmcgc2l0dWF0aW9uIHdoZW4gc2V2ZXJhbCBzdHJlYW1zIGhhcyB0aGUgc2FtZSBsZXZlbFxuICAgIGxldCByZWNvcmRlZExldmVsID0gMFxuICAgIGxldCBzdHJlYW1cblxuICAgIC8vIGlmIGRlZHVwZSBzZXQgdG8gdHJ1ZSB3ZSBzZW5kIGxvZ3MgdG8gdGhlIHN0cmVhbSB3aXRoIHRoZSBoaWdoZXN0IGxldmVsXG4gICAgLy8gdGhlcmVmb3JlLCB3ZSBoYXZlIHRvIGNoYW5nZSBzb3J0aW5nIG9yZGVyXG4gICAgZm9yIChsZXQgaSA9IGluaXRMb29wVmFyKHN0cmVhbXMubGVuZ3RoLCBvcHRzLmRlZHVwZSk7IGNoZWNrTG9vcFZhcihpLCBzdHJlYW1zLmxlbmd0aCwgb3B0cy5kZWR1cGUpOyBpID0gYWRqdXN0TG9vcFZhcihpLCBvcHRzLmRlZHVwZSkpIHtcbiAgICAgIGRlc3QgPSBzdHJlYW1zW2ldXG4gICAgICBpZiAoZGVzdC5sZXZlbCA8PSBsZXZlbCkge1xuICAgICAgICBpZiAocmVjb3JkZWRMZXZlbCAhPT0gMCAmJiByZWNvcmRlZExldmVsICE9PSBkZXN0LmxldmVsKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0gPSBkZXN0LnN0cmVhbVxuICAgICAgICBpZiAoc3RyZWFtW21ldGFkYXRhXSkge1xuICAgICAgICAgIGNvbnN0IHsgbGFzdFRpbWUsIGxhc3RNc2csIGxhc3RPYmosIGxhc3RMb2dnZXIgfSA9IHRoaXNcbiAgICAgICAgICBzdHJlYW0ubGFzdExldmVsID0gbGV2ZWxcbiAgICAgICAgICBzdHJlYW0ubGFzdFRpbWUgPSBsYXN0VGltZVxuICAgICAgICAgIHN0cmVhbS5sYXN0TXNnID0gbGFzdE1zZ1xuICAgICAgICAgIHN0cmVhbS5sYXN0T2JqID0gbGFzdE9ialxuICAgICAgICAgIHN0cmVhbS5sYXN0TG9nZ2VyID0gbGFzdExvZ2dlclxuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS53cml0ZShkYXRhKVxuICAgICAgICBpZiAob3B0cy5kZWR1cGUpIHtcbiAgICAgICAgICByZWNvcmRlZExldmVsID0gZGVzdC5sZXZlbFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFvcHRzLmRlZHVwZSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXQgKC4uLmFyZ3MpIHtcbiAgICBmb3IgKGNvbnN0IHsgc3RyZWFtIH0gb2YgdGhpcy5zdHJlYW1zKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmVhbS5lbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KC4uLmFyZ3MpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hTeW5jICgpIHtcbiAgICBmb3IgKGNvbnN0IHsgc3RyZWFtIH0gb2YgdGhpcy5zdHJlYW1zKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmVhbS5mbHVzaFN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3RyZWFtLmZsdXNoU3luYygpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkIChkZXN0KSB7XG4gICAgaWYgKCFkZXN0KSB7XG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhhdCBkZXN0IGltcGxlbWVudHMgZWl0aGVyIFN0cmVhbUVudHJ5IG9yIERlc3RpbmF0aW9uU3RyZWFtXG4gICAgY29uc3QgaXNTdHJlYW0gPSB0eXBlb2YgZGVzdC53cml0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBkZXN0LnN0cmVhbVxuICAgIGNvbnN0IHN0cmVhbV8gPSBkZXN0LndyaXRlID8gZGVzdCA6IGRlc3Quc3RyZWFtXG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gcHJvdmlkZSBhIG1lYW5pbmdmdWwgZXJyb3IgbWVzc2FnZSwgb3RoZXJ3aXNlIGl0IHRocm93cyBzb21ld2hlcmUgaW5zaWRlIHdyaXRlKClcbiAgICBpZiAoIWlzU3RyZWFtKSB7XG4gICAgICB0aHJvdyBFcnJvcignc3RyZWFtIG9iamVjdCBuZWVkcyB0byBpbXBsZW1lbnQgZWl0aGVyIFN0cmVhbUVudHJ5IG9yIERlc3RpbmF0aW9uU3RyZWFtIGludGVyZmFjZScpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzdHJlYW1zLCBzdHJlYW1MZXZlbHMgfSA9IHRoaXNcblxuICAgIGxldCBsZXZlbFxuICAgIGlmICh0eXBlb2YgZGVzdC5sZXZlbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGxldmVsID0gZGVzdC5sZXZlbFZhbFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3QubGV2ZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXZlbCA9IHN0cmVhbUxldmVsc1tkZXN0LmxldmVsXVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3QubGV2ZWwgPT09ICdudW1iZXInKSB7XG4gICAgICBsZXZlbCA9IGRlc3QubGV2ZWxcbiAgICB9IGVsc2Uge1xuICAgICAgbGV2ZWwgPSBERUZBVUxUX0lORk9fTEVWRUxcbiAgICB9XG5cbiAgICBjb25zdCBkZXN0XyA9IHtcbiAgICAgIHN0cmVhbTogc3RyZWFtXyxcbiAgICAgIGxldmVsLFxuICAgICAgbGV2ZWxWYWw6IHVuZGVmaW5lZCxcbiAgICAgIGlkOiBjb3VudGVyKytcbiAgICB9XG5cbiAgICBzdHJlYW1zLnVuc2hpZnQoZGVzdF8pXG4gICAgc3RyZWFtcy5zb3J0KGNvbXBhcmVCeUxldmVsKVxuXG4gICAgdGhpcy5taW5MZXZlbCA9IHN0cmVhbXNbMF0ubGV2ZWxcblxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgZm9yIChjb25zdCB7IHN0cmVhbSB9IG9mIHRoaXMuc3RyZWFtcykge1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW0uZmx1c2hTeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0cmVhbS5mbHVzaFN5bmMoKVxuICAgICAgfVxuICAgICAgc3RyZWFtLmVuZCgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmUgKGxldmVsKSB7XG4gICAgY29uc3Qgc3RyZWFtcyA9IG5ldyBBcnJheSh0aGlzLnN0cmVhbXMubGVuZ3RoKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdHJlYW1zW2ldID0ge1xuICAgICAgICBsZXZlbCxcbiAgICAgICAgc3RyZWFtOiB0aGlzLnN0cmVhbXNbaV0uc3RyZWFtXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlLFxuICAgICAgYWRkLFxuICAgICAgbWluTGV2ZWw6IGxldmVsLFxuICAgICAgc3RyZWFtcyxcbiAgICAgIGNsb25lLFxuICAgICAgZW1pdCxcbiAgICAgIGZsdXNoU3luYyxcbiAgICAgIFttZXRhZGF0YV06IHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZUJ5TGV2ZWwgKGEsIGIpIHtcbiAgcmV0dXJuIGEubGV2ZWwgLSBiLmxldmVsXG59XG5cbmZ1bmN0aW9uIGluaXRMb29wVmFyIChsZW5ndGgsIGRlZHVwZSkge1xuICByZXR1cm4gZGVkdXBlID8gbGVuZ3RoIC0gMSA6IDBcbn1cblxuZnVuY3Rpb24gYWRqdXN0TG9vcFZhciAoaSwgZGVkdXBlKSB7XG4gIHJldHVybiBkZWR1cGUgPyBpIC0gMSA6IGkgKyAxXG59XG5cbmZ1bmN0aW9uIGNoZWNrTG9vcFZhciAoaSwgbGVuZ3RoLCBkZWR1cGUpIHtcbiAgcmV0dXJuIGRlZHVwZSA/IGkgPj0gMCA6IGkgPCBsZW5ndGhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtdWx0aXN0cmVhbVxuIl0sIm5hbWVzIjpbIm1ldGFkYXRhIiwiU3ltYm9sIiwiZm9yIiwiREVGQVVMVF9MRVZFTFMiLCJyZXF1aXJlIiwiREVGQVVMVF9JTkZPX0xFVkVMIiwiaW5mbyIsIm11bHRpc3RyZWFtIiwic3RyZWFtc0FycmF5Iiwib3B0cyIsImNvdW50ZXIiLCJkZWR1cGUiLCJzdHJlYW1MZXZlbHMiLCJPYmplY3QiLCJjcmVhdGUiLCJzaWxlbnQiLCJJbmZpbml0eSIsImxldmVscyIsImtleXMiLCJmb3JFYWNoIiwiaSIsInJlcyIsIndyaXRlIiwiYWRkIiwiZW1pdCIsImZsdXNoU3luYyIsImVuZCIsIm1pbkxldmVsIiwic3RyZWFtcyIsImNsb25lIiwiQXJyYXkiLCJpc0FycmF5IiwiY2FsbCIsImRhdGEiLCJkZXN0IiwibGV2ZWwiLCJsYXN0TGV2ZWwiLCJyZWNvcmRlZExldmVsIiwic3RyZWFtIiwiaW5pdExvb3BWYXIiLCJsZW5ndGgiLCJjaGVja0xvb3BWYXIiLCJhZGp1c3RMb29wVmFyIiwibGFzdFRpbWUiLCJsYXN0TXNnIiwibGFzdE9iaiIsImxhc3RMb2dnZXIiLCJhcmdzIiwiaXNTdHJlYW0iLCJzdHJlYW1fIiwiRXJyb3IiLCJsZXZlbFZhbCIsImRlc3RfIiwidW5kZWZpbmVkIiwiaWQiLCJ1bnNoaWZ0Iiwic29ydCIsImNvbXBhcmVCeUxldmVsIiwiYSIsImIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/multistream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/proto.js":
/*!****************************************!*\
  !*** ./node_modules/pino/lib/proto.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/* eslint no-prototype-builtins: 0 */ const { EventEmitter } = __webpack_require__(/*! events */ \"events\");\nconst { lsCacheSym, levelValSym, setLevelSym, getLevelSym, chindingsSym, parsedChindingsSym, mixinSym, asJsonSym, writeSym, mixinMergeStrategySym, timeSym, timeSliceIndexSym, streamSym, serializersSym, formattersSym, errorKeySym, messageKeySym, useOnlyCustomLevelsSym, needsMetadataGsym, redactFmtSym, stringifySym, formatOptsSym, stringifiersSym, msgPrefixSym } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/pino/lib/symbols.js\");\nconst { getLevel, setLevel, isLevelEnabled, mappings, initialLsCache, genLsCache, assertNoLevelCollisions } = __webpack_require__(/*! ./levels */ \"(rsc)/./node_modules/pino/lib/levels.js\");\nconst { asChindings, asJson, buildFormatters, stringify } = __webpack_require__(/*! ./tools */ \"(rsc)/./node_modules/pino/lib/tools.js\");\nconst { version } = __webpack_require__(/*! ./meta */ \"(rsc)/./node_modules/pino/lib/meta.js\");\nconst redaction = __webpack_require__(/*! ./redaction */ \"(rsc)/./node_modules/pino/lib/redaction.js\");\n// note: use of class is satirical\n// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127\nconst constructor = class Pino {\n};\nconst prototype = {\n    constructor,\n    child,\n    bindings,\n    setBindings,\n    flush,\n    isLevelEnabled,\n    version,\n    get level () {\n        return this[getLevelSym]();\n    },\n    set level (lvl){\n        this[setLevelSym](lvl);\n    },\n    get levelVal () {\n        return this[levelValSym];\n    },\n    set levelVal (n){\n        throw Error(\"levelVal is read-only\");\n    },\n    [lsCacheSym]: initialLsCache,\n    [writeSym]: write,\n    [asJsonSym]: asJson,\n    [getLevelSym]: getLevel,\n    [setLevelSym]: setLevel\n};\nObject.setPrototypeOf(prototype, EventEmitter.prototype);\n// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing\nmodule.exports = function() {\n    return Object.create(prototype);\n};\nconst resetChildingsFormatter = (bindings)=>bindings;\nfunction child(bindings, options) {\n    if (!bindings) {\n        throw Error(\"missing bindings for child Pino\");\n    }\n    options = options || {} // default options to empty object\n    ;\n    const serializers = this[serializersSym];\n    const formatters = this[formattersSym];\n    const instance = Object.create(this);\n    if (options.hasOwnProperty(\"serializers\") === true) {\n        instance[serializersSym] = Object.create(null);\n        for(const k in serializers){\n            instance[serializersSym][k] = serializers[k];\n        }\n        const parentSymbols = Object.getOwnPropertySymbols(serializers);\n        /* eslint no-var: off */ for(var i = 0; i < parentSymbols.length; i++){\n            const ks = parentSymbols[i];\n            instance[serializersSym][ks] = serializers[ks];\n        }\n        for(const bk in options.serializers){\n            instance[serializersSym][bk] = options.serializers[bk];\n        }\n        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);\n        for(var bi = 0; bi < bindingsSymbols.length; bi++){\n            const bks = bindingsSymbols[bi];\n            instance[serializersSym][bks] = options.serializers[bks];\n        }\n    } else instance[serializersSym] = serializers;\n    if (options.hasOwnProperty(\"formatters\")) {\n        const { level, bindings: chindings, log } = options.formatters;\n        instance[formattersSym] = buildFormatters(level || formatters.level, chindings || resetChildingsFormatter, log || formatters.log);\n    } else {\n        instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);\n    }\n    if (options.hasOwnProperty(\"customLevels\") === true) {\n        assertNoLevelCollisions(this.levels, options.customLevels);\n        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);\n        genLsCache(instance);\n    }\n    // redact must place before asChindings and only replace if exist\n    if (typeof options.redact === \"object\" && options.redact !== null || Array.isArray(options.redact)) {\n        instance.redact = options.redact // replace redact directly\n        ;\n        const stringifiers = redaction(instance.redact, stringify);\n        const formatOpts = {\n            stringify: stringifiers[redactFmtSym]\n        };\n        instance[stringifySym] = stringify;\n        instance[stringifiersSym] = stringifiers;\n        instance[formatOptsSym] = formatOpts;\n    }\n    if (typeof options.msgPrefix === \"string\") {\n        instance[msgPrefixSym] = (this[msgPrefixSym] || \"\") + options.msgPrefix;\n    }\n    instance[chindingsSym] = asChindings(instance, bindings);\n    const childLevel = options.level || this.level;\n    instance[setLevelSym](childLevel);\n    this.onChild(instance);\n    return instance;\n}\nfunction bindings() {\n    const chindings = this[chindingsSym];\n    const chindingsJson = `{${chindings.substr(1)}}` // at least contains ,\"pid\":7068,\"hostname\":\"myMac\"\n    ;\n    const bindingsFromJson = JSON.parse(chindingsJson);\n    delete bindingsFromJson.pid;\n    delete bindingsFromJson.hostname;\n    return bindingsFromJson;\n}\nfunction setBindings(newBindings) {\n    const chindings = asChindings(this, newBindings);\n    this[chindingsSym] = chindings;\n    delete this[parsedChindingsSym];\n}\n/**\n * Default strategy for creating `mergeObject` from arguments and the result from `mixin()`.\n * Fields from `mergeObject` have higher priority in this strategy.\n *\n * @param {Object} mergeObject The object a user has supplied to the logging function.\n * @param {Object} mixinObject The result of the `mixin` method.\n * @return {Object}\n */ function defaultMixinMergeStrategy(mergeObject, mixinObject) {\n    return Object.assign(mixinObject, mergeObject);\n}\nfunction write(_obj, msg, num) {\n    const t = this[timeSym]();\n    const mixin = this[mixinSym];\n    const errorKey = this[errorKeySym];\n    const messageKey = this[messageKeySym];\n    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;\n    let obj;\n    if (_obj === undefined || _obj === null) {\n        obj = {};\n    } else if (_obj instanceof Error) {\n        obj = {\n            [errorKey]: _obj\n        };\n        if (msg === undefined) {\n            msg = _obj.message;\n        }\n    } else {\n        obj = _obj;\n        if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {\n            msg = _obj[errorKey].message;\n        }\n    }\n    if (mixin) {\n        obj = mixinMergeStrategy(obj, mixin(obj, num, this));\n    }\n    const s = this[asJsonSym](obj, msg, num, t);\n    const stream = this[streamSym];\n    if (stream[needsMetadataGsym] === true) {\n        stream.lastLevel = num;\n        stream.lastObj = obj;\n        stream.lastMsg = msg;\n        stream.lastTime = t.slice(this[timeSliceIndexSym]);\n        stream.lastLogger = this // for child loggers\n        ;\n    }\n    stream.write(s);\n}\nfunction noop() {}\nfunction flush(cb) {\n    if (cb != null && typeof cb !== \"function\") {\n        throw Error(\"callback must be a function\");\n    }\n    const stream = this[streamSym];\n    if (typeof stream.flush === \"function\") {\n        stream.flush(cb || noop);\n    } else if (cb) cb();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvcHJvdG8uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxtQ0FBbUMsR0FFbkMsTUFBTSxFQUFFQSxZQUFZLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDakMsTUFBTSxFQUNKQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLFlBQVksRUFDWkMsa0JBQWtCLEVBQ2xCQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsUUFBUSxFQUNSQyxxQkFBcUIsRUFDckJDLE9BQU8sRUFDUEMsaUJBQWlCLEVBQ2pCQyxTQUFTLEVBQ1RDLGNBQWMsRUFDZEMsYUFBYSxFQUNiQyxXQUFXLEVBQ1hDLGFBQWEsRUFDYkMsc0JBQXNCLEVBQ3RCQyxpQkFBaUIsRUFDakJDLFlBQVksRUFDWkMsWUFBWSxFQUNaQyxhQUFhLEVBQ2JDLGVBQWUsRUFDZkMsWUFBWSxFQUNiLEdBQUd4QixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFDSnlCLFFBQVEsRUFDUkMsUUFBUSxFQUNSQyxjQUFjLEVBQ2RDLFFBQVEsRUFDUkMsY0FBYyxFQUNkQyxVQUFVLEVBQ1ZDLHVCQUF1QixFQUN4QixHQUFHL0IsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0pnQyxXQUFXLEVBQ1hDLE1BQU0sRUFDTkMsZUFBZSxFQUNmQyxTQUFTLEVBQ1YsR0FBR25DLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUNKb0MsT0FBTyxFQUNSLEdBQUdwQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU1xQyxZQUFZckMsbUJBQU9BLENBQUM7QUFFMUIsa0NBQWtDO0FBQ2xDLHNFQUFzRTtBQUN0RSxNQUFNc0MsY0FBYyxNQUFNQztBQUFNO0FBQ2hDLE1BQU1DLFlBQVk7SUFDaEJGO0lBQ0FHO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FqQjtJQUNBUztJQUNBLElBQUlTLFNBQVM7UUFBRSxPQUFPLElBQUksQ0FBQ3pDLFlBQVk7SUFBRztJQUMxQyxJQUFJeUMsT0FB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LElBQUksSUFBSSxDQUFDbkcsVUFBVSxDQUFDZ0csS0FBS1AsS0FBS0MsS0FBS0M7SUFFekMsTUFBTVMsU0FBUyxJQUFJLENBQUMvRixVQUFVO0lBQzlCLElBQUkrRixNQUFNLENBQUN6RixrQkFBa0IsS0FBSyxNQUFNO1FBQ3RDeUYsT0FBT0MsU0FBUyxHQUFHWDtRQUNuQlUsT0FBT0UsT0FBTyxHQUFHTjtRQUNqQkksT0FBT0csT0FBTyxHQUFHZDtRQUNqQlcsT0FBT0ksUUFBUSxHQUFHYixFQUFFYyxLQUFLLENBQUMsSUFBSSxDQUFDckcsa0JBQWtCO1FBQ2pEZ0csT0FBT00sVUFBVSxHQUFHLElBQUksQ0FBQyxvQkFBb0I7O0lBQy9DO0lBQ0FOLE9BQU8xRCxLQUFLLENBQUN5RDtBQUNmO0FBRUEsU0FBU1EsUUFBUztBQUVsQixTQUFTdkUsTUFBT3dFLEVBQUU7SUFDaEIsSUFBSUEsTUFBTSxRQUFRLE9BQU9BLE9BQU8sWUFBWTtRQUMxQyxNQUFNbkUsTUFBTTtJQUNkO0lBRUEsTUFBTTJELFNBQVMsSUFBSSxDQUFDL0YsVUFBVTtJQUU5QixJQUFJLE9BQU8rRixPQUFPaEUsS0FBSyxLQUFLLFlBQVk7UUFDdENnRSxPQUFPaEUsS0FBSyxDQUFDd0UsTUFBTUQ7SUFDckIsT0FBTyxJQUFJQyxJQUFJQTtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL25lY3Rhci1hZG1pbi12MS8uL25vZGVfbW9kdWxlcy9waW5vL2xpYi9wcm90by5qcz9lMGRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKiBlc2xpbnQgbm8tcHJvdG90eXBlLWJ1aWx0aW5zOiAwICovXG5cbmNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3Qge1xuICBsc0NhY2hlU3ltLFxuICBsZXZlbFZhbFN5bSxcbiAgc2V0TGV2ZWxTeW0sXG4gIGdldExldmVsU3ltLFxuICBjaGluZGluZ3NTeW0sXG4gIHBhcnNlZENoaW5kaW5nc1N5bSxcbiAgbWl4aW5TeW0sXG4gIGFzSnNvblN5bSxcbiAgd3JpdGVTeW0sXG4gIG1peGluTWVyZ2VTdHJhdGVneVN5bSxcbiAgdGltZVN5bSxcbiAgdGltZVNsaWNlSW5kZXhTeW0sXG4gIHN0cmVhbVN5bSxcbiAgc2VyaWFsaXplcnNTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBtZXNzYWdlS2V5U3ltLFxuICB1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltLFxuICBuZWVkc01ldGFkYXRhR3N5bSxcbiAgcmVkYWN0Rm10U3ltLFxuICBzdHJpbmdpZnlTeW0sXG4gIGZvcm1hdE9wdHNTeW0sXG4gIHN0cmluZ2lmaWVyc1N5bSxcbiAgbXNnUHJlZml4U3ltXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHtcbiAgZ2V0TGV2ZWwsXG4gIHNldExldmVsLFxuICBpc0xldmVsRW5hYmxlZCxcbiAgbWFwcGluZ3MsXG4gIGluaXRpYWxMc0NhY2hlLFxuICBnZW5Mc0NhY2hlLFxuICBhc3NlcnROb0xldmVsQ29sbGlzaW9uc1xufSA9IHJlcXVpcmUoJy4vbGV2ZWxzJylcbmNvbnN0IHtcbiAgYXNDaGluZGluZ3MsXG4gIGFzSnNvbixcbiAgYnVpbGRGb3JtYXR0ZXJzLFxuICBzdHJpbmdpZnlcbn0gPSByZXF1aXJlKCcuL3Rvb2xzJylcbmNvbnN0IHtcbiAgdmVyc2lvblxufSA9IHJlcXVpcmUoJy4vbWV0YScpXG5jb25zdCByZWRhY3Rpb24gPSByZXF1aXJlKCcuL3JlZGFjdGlvbicpXG5cbi8vIG5vdGU6IHVzZSBvZiBjbGFzcyBpcyBzYXRpcmljYWxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waW5vanMvcGluby9wdWxsLzQzMyNwdWxscmVxdWVzdHJldmlldy0xMjc3MDMxMjdcbmNvbnN0IGNvbnN0cnVjdG9yID0gY2xhc3MgUGlubyB7fVxuY29uc3QgcHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcixcbiAgY2hpbGQsXG4gIGJpbmRpbmdzLFxuICBzZXRCaW5kaW5ncyxcbiAgZmx1c2gsXG4gIGlzTGV2ZWxFbmFibGVkLFxuICB2ZXJzaW9uLFxuICBnZXQgbGV2ZWwgKCkgeyByZXR1cm4gdGhpc1tnZXRMZXZlbFN5bV0oKSB9LFxuICBzZXQgbGV2ZWwgKGx2bCkgeyB0aGlzW3NldExldmVsU3ltXShsdmwpIH0sXG4gIGdldCBsZXZlbFZhbCAoKSB7IHJldHVybiB0aGlzW2xldmVsVmFsU3ltXSB9LFxuICBzZXQgbGV2ZWxWYWwgKG4pIHsgdGhyb3cgRXJyb3IoJ2xldmVsVmFsIGlzIHJlYWQtb25seScpIH0sXG4gIFtsc0NhY2hlU3ltXTogaW5pdGlhbExzQ2FjaGUsXG4gIFt3cml0ZVN5bV06IHdyaXRlLFxuICBbYXNKc29uU3ltXTogYXNKc29uLFxuICBbZ2V0TGV2ZWxTeW1dOiBnZXRMZXZlbCxcbiAgW3NldExldmVsU3ltXTogc2V0TGV2ZWxcbn1cblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSlcblxuLy8gZXhwb3J0aW5nIGFuZCBjb25zdW1pbmcgdGhlIHByb3RvdHlwZSBvYmplY3QgdXNpbmcgZmFjdG9yeSBwYXR0ZXJuIGZpeGVzIHNjb3BpbmcgaXNzdWVzIHdpdGggZ2V0dGVycyB3aGVuIHNlcmlhbGl6aW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUocHJvdG90eXBlKVxufVxuXG5jb25zdCByZXNldENoaWxkaW5nc0Zvcm1hdHRlciA9IGJpbmRpbmdzID0+IGJpbmRpbmdzXG5mdW5jdGlvbiBjaGlsZCAoYmluZGluZ3MsIG9wdGlvbnMpIHtcbiAgaWYgKCFiaW5kaW5ncykge1xuICAgIHRocm93IEVycm9yKCdtaXNzaW5nIGJpbmRpbmdzIGZvciBjaGlsZCBQaW5vJylcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fSAvLyBkZWZhdWx0IG9wdGlvbnMgdG8gZW1wdHkgb2JqZWN0XG4gIGNvbnN0IHNlcmlhbGl6ZXJzID0gdGhpc1tzZXJpYWxpemVyc1N5bV1cbiAgY29uc3QgZm9ybWF0dGVycyA9IHRoaXNbZm9ybWF0dGVyc1N5bV1cbiAgY29uc3QgaW5zdGFuY2UgPSBPYmplY3QuY3JlYXRlKHRoaXMpXG5cbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3NlcmlhbGl6ZXJzJykgPT09IHRydWUpIHtcbiAgICBpbnN0YW5jZVtzZXJpYWxpemVyc1N5bV0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICBmb3IgKGNvbnN0IGsgaW4gc2VyaWFsaXplcnMpIHtcbiAgICAgIGluc3RhbmNlW3NlcmlhbGl6ZXJzU3ltXVtrXSA9IHNlcmlhbGl6ZXJzW2tdXG4gICAgfVxuICAgIGNvbnN0IHBhcmVudFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNlcmlhbGl6ZXJzKVxuICAgIC8qIGVzbGludCBuby12YXI6IG9mZiAqL1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga3MgPSBwYXJlbnRTeW1ib2xzW2ldXG4gICAgICBpbnN0YW5jZVtzZXJpYWxpemVyc1N5bV1ba3NdID0gc2VyaWFsaXplcnNba3NdXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBiayBpbiBvcHRpb25zLnNlcmlhbGl6ZXJzKSB7XG4gICAgICBpbnN0YW5jZVtzZXJpYWxpemVyc1N5bV1bYmtdID0gb3B0aW9ucy5zZXJpYWxpemVyc1tia11cbiAgICB9XG4gICAgY29uc3QgYmluZGluZ3NTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvcHRpb25zLnNlcmlhbGl6ZXJzKVxuICAgIGZvciAodmFyIGJpID0gMDsgYmkgPCBiaW5kaW5nc1N5bWJvbHMubGVuZ3RoOyBiaSsrKSB7XG4gICAgICBjb25zdCBia3MgPSBiaW5kaW5nc1N5bWJvbHNbYmldXG4gICAgICBpbnN0YW5jZVtzZXJpYWxpemVyc1N5bV1bYmtzXSA9IG9wdGlvbnMuc2VyaWFsaXplcnNbYmtzXVxuICAgIH1cbiAgfSBlbHNlIGluc3RhbmNlW3NlcmlhbGl6ZXJzU3ltXSA9IHNlcmlhbGl6ZXJzXG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdmb3JtYXR0ZXJzJykpIHtcbiAgICBjb25zdCB7IGxldmVsLCBiaW5kaW5nczogY2hpbmRpbmdzLCBsb2cgfSA9IG9wdGlvbnMuZm9ybWF0dGVyc1xuICAgIGluc3RhbmNlW2Zvcm1hdHRlcnNTeW1dID0gYnVpbGRGb3JtYXR0ZXJzKFxuICAgICAgbGV2ZWwgfHwgZm9ybWF0dGVycy5sZXZlbCxcbiAgICAgIGNoaW5kaW5ncyB8fCByZXNldENoaWxkaW5nc0Zvcm1hdHRlcixcbiAgICAgIGxvZyB8fCBmb3JtYXR0ZXJzLmxvZ1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZVtmb3JtYXR0ZXJzU3ltXSA9IGJ1aWxkRm9ybWF0dGVycyhcbiAgICAgIGZvcm1hdHRlcnMubGV2ZWwsXG4gICAgICByZXNldENoaWxkaW5nc0Zvcm1hdHRlcixcbiAgICAgIGZvcm1hdHRlcnMubG9nXG4gICAgKVxuICB9XG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdjdXN0b21MZXZlbHMnKSA9PT0gdHJ1ZSkge1xuICAgIGFzc2VydE5vTGV2ZWxDb2xsaXNpb25zKHRoaXMubGV2ZWxzLCBvcHRpb25zLmN1c3RvbUxldmVscylcbiAgICBpbnN0YW5jZS5sZXZlbHMgPSBtYXBwaW5ncyhvcHRpb25zLmN1c3RvbUxldmVscywgaW5zdGFuY2VbdXNlT25seUN1c3RvbUxldmVsc1N5bV0pXG4gICAgZ2VuTHNDYWNoZShpbnN0YW5jZSlcbiAgfVxuXG4gIC8vIHJlZGFjdCBtdXN0IHBsYWNlIGJlZm9yZSBhc0NoaW5kaW5ncyBhbmQgb25seSByZXBsYWNlIGlmIGV4aXN0XG4gIGlmICgodHlwZW9mIG9wdGlvbnMucmVkYWN0ID09PSAnb2JqZWN0JyAmJiBvcHRpb25zLnJlZGFjdCAhPT0gbnVsbCkgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLnJlZGFjdCkpIHtcbiAgICBpbnN0YW5jZS5yZWRhY3QgPSBvcHRpb25zLnJlZGFjdCAvLyByZXBsYWNlIHJlZGFjdCBkaXJlY3RseVxuICAgIGNvbnN0IHN0cmluZ2lmaWVycyA9IHJlZGFjdGlvbihpbnN0YW5jZS5yZWRhY3QsIHN0cmluZ2lmeSlcbiAgICBjb25zdCBmb3JtYXRPcHRzID0geyBzdHJpbmdpZnk6IHN0cmluZ2lmaWVyc1tyZWRhY3RGbXRTeW1dIH1cbiAgICBpbnN0YW5jZVtzdHJpbmdpZnlTeW1dID0gc3RyaW5naWZ5XG4gICAgaW5zdGFuY2Vbc3RyaW5naWZpZXJzU3ltXSA9IHN0cmluZ2lmaWVyc1xuICAgIGluc3RhbmNlW2Zvcm1hdE9wdHNTeW1dID0gZm9ybWF0T3B0c1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm1zZ1ByZWZpeCA9PT0gJ3N0cmluZycpIHtcbiAgICBpbnN0YW5jZVttc2dQcmVmaXhTeW1dID0gKHRoaXNbbXNnUHJlZml4U3ltXSB8fCAnJykgKyBvcHRpb25zLm1zZ1ByZWZpeFxuICB9XG5cbiAgaW5zdGFuY2VbY2hpbmRpbmdzU3ltXSA9IGFzQ2hpbmRpbmdzKGluc3RhbmNlLCBiaW5kaW5ncylcbiAgY29uc3QgY2hpbGRMZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgdGhpcy5sZXZlbFxuICBpbnN0YW5jZVtzZXRMZXZlbFN5bV0oY2hpbGRMZXZlbClcbiAgdGhpcy5vbkNoaWxkKGluc3RhbmNlKVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxuZnVuY3Rpb24gYmluZGluZ3MgKCkge1xuICBjb25zdCBjaGluZGluZ3MgPSB0aGlzW2NoaW5kaW5nc1N5bV1cbiAgY29uc3QgY2hpbmRpbmdzSnNvbiA9IGB7JHtjaGluZGluZ3Muc3Vic3RyKDEpfX1gIC8vIGF0IGxlYXN0IGNvbnRhaW5zICxcInBpZFwiOjcwNjgsXCJob3N0bmFtZVwiOlwibXlNYWNcIlxuICBjb25zdCBiaW5kaW5nc0Zyb21Kc29uID0gSlNPTi5wYXJzZShjaGluZGluZ3NKc29uKVxuICBkZWxldGUgYmluZGluZ3NGcm9tSnNvbi5waWRcbiAgZGVsZXRlIGJpbmRpbmdzRnJvbUpzb24uaG9zdG5hbWVcbiAgcmV0dXJuIGJpbmRpbmdzRnJvbUpzb25cbn1cblxuZnVuY3Rpb24gc2V0QmluZGluZ3MgKG5ld0JpbmRpbmdzKSB7XG4gIGNvbnN0IGNoaW5kaW5ncyA9IGFzQ2hpbmRpbmdzKHRoaXMsIG5ld0JpbmRpbmdzKVxuICB0aGlzW2NoaW5kaW5nc1N5bV0gPSBjaGluZGluZ3NcbiAgZGVsZXRlIHRoaXNbcGFyc2VkQ2hpbmRpbmdzU3ltXVxufVxuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kgZm9yIGNyZWF0aW5nIGBtZXJnZU9iamVjdGAgZnJvbSBhcmd1bWVudHMgYW5kIHRoZSByZXN1bHQgZnJvbSBgbWl4aW4oKWAuXG4gKiBGaWVsZHMgZnJvbSBgbWVyZ2VPYmplY3RgIGhhdmUgaGlnaGVyIHByaW9yaXR5IGluIHRoaXMgc3RyYXRlZ3kuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1lcmdlT2JqZWN0IFRoZSBvYmplY3QgYSB1c2VyIGhhcyBzdXBwbGllZCB0byB0aGUgbG9nZ2luZyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtaXhpbk9iamVjdCBUaGUgcmVzdWx0IG9mIHRoZSBgbWl4aW5gIG1ldGhvZC5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdE1peGluTWVyZ2VTdHJhdGVneSAobWVyZ2VPYmplY3QsIG1peGluT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG1peGluT2JqZWN0LCBtZXJnZU9iamVjdClcbn1cblxuZnVuY3Rpb24gd3JpdGUgKF9vYmosIG1zZywgbnVtKSB7XG4gIGNvbnN0IHQgPSB0aGlzW3RpbWVTeW1dKClcbiAgY29uc3QgbWl4aW4gPSB0aGlzW21peGluU3ltXVxuICBjb25zdCBlcnJvcktleSA9IHRoaXNbZXJyb3JLZXlTeW1dXG4gIGNvbnN0IG1lc3NhZ2VLZXkgPSB0aGlzW21lc3NhZ2VLZXlTeW1dXG4gIGNvbnN0IG1peGluTWVyZ2VTdHJhdGVneSA9IHRoaXNbbWl4aW5NZXJnZVN0cmF0ZWd5U3ltXSB8fCBkZWZhdWx0TWl4aW5NZXJnZVN0cmF0ZWd5XG4gIGxldCBvYmpcblxuICBpZiAoX29iaiA9PT0gdW5kZWZpbmVkIHx8IF9vYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB7fVxuICB9IGVsc2UgaWYgKF9vYmogaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIG9iaiA9IHsgW2Vycm9yS2V5XTogX29iaiB9XG4gICAgaWYgKG1zZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtc2cgPSBfb2JqLm1lc3NhZ2VcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb2JqID0gX29ialxuICAgIGlmIChtc2cgPT09IHVuZGVmaW5lZCAmJiBfb2JqW21lc3NhZ2VLZXldID09PSB1bmRlZmluZWQgJiYgX29ialtlcnJvcktleV0pIHtcbiAgICAgIG1zZyA9IF9vYmpbZXJyb3JLZXldLm1lc3NhZ2VcbiAgICB9XG4gIH1cblxuICBpZiAobWl4aW4pIHtcbiAgICBvYmogPSBtaXhpbk1lcmdlU3RyYXRlZ3kob2JqLCBtaXhpbihvYmosIG51bSwgdGhpcykpXG4gIH1cblxuICBjb25zdCBzID0gdGhpc1thc0pzb25TeW1dKG9iaiwgbXNnLCBudW0sIHQpXG5cbiAgY29uc3Qgc3RyZWFtID0gdGhpc1tzdHJlYW1TeW1dXG4gIGlmIChzdHJlYW1bbmVlZHNNZXRhZGF0YUdzeW1dID09PSB0cnVlKSB7XG4gICAgc3RyZWFtLmxhc3RMZXZlbCA9IG51bVxuICAgIHN0cmVhbS5sYXN0T2JqID0gb2JqXG4gICAgc3RyZWFtLmxhc3RNc2cgPSBtc2dcbiAgICBzdHJlYW0ubGFzdFRpbWUgPSB0LnNsaWNlKHRoaXNbdGltZVNsaWNlSW5kZXhTeW1dKVxuICAgIHN0cmVhbS5sYXN0TG9nZ2VyID0gdGhpcyAvLyBmb3IgY2hpbGQgbG9nZ2Vyc1xuICB9XG4gIHN0cmVhbS53cml0ZShzKVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIGZsdXNoIChjYikge1xuICBpZiAoY2IgIT0gbnVsbCAmJiB0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IHRoaXNbc3RyZWFtU3ltXVxuXG4gIGlmICh0eXBlb2Ygc3RyZWFtLmZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyZWFtLmZsdXNoKGNiIHx8IG5vb3ApXG4gIH0gZWxzZSBpZiAoY2IpIGNiKClcbn1cbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwibHNDYWNoZVN5bSIsImxldmVsVmFsU3ltIiwic2V0TGV2ZWxTeW0iLCJnZXRMZXZlbFN5bSIsImNoaW5kaW5nc1N5bSIsInBhcnNlZENoaW5kaW5nc1N5bSIsIm1peGluU3ltIiwiYXNKc29uU3ltIiwid3JpdGVTeW0iLCJtaXhpbk1lcmdlU3RyYXRlZ3lTeW0iLCJ0aW1lU3ltIiwidGltZVNsaWNlSW5kZXhTeW0iLCJzdHJlYW1TeW0iLCJzZXJpYWxpemVyc1N5bSIsImZvcm1hdHRlcnNTeW0iLCJlcnJvcktleVN5bSIsIm1lc3NhZ2VLZXlTeW0iLCJ1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltIiwibmVlZHNNZXRhZGF0YUdzeW0iLCJyZWRhY3RGbXRTeW0iLCJzdHJpbmdpZnlTeW0iLCJmb3JtYXRPcHRzU3ltIiwic3RyaW5naWZpZXJzU3ltIiwibXNnUHJlZml4U3ltIiwiZ2V0TGV2ZWwiLCJzZXRMZXZlbCIsImlzTGV2ZWxFbmFibGVkIiwibWFwcGluZ3MiLCJpbml0aWFsTHNDYWNoZSIsImdlbkxzQ2FjaGUiLCJhc3NlcnROb0xldmVsQ29sbGlzaW9ucyIsImFzQ2hpbmRpbmdzIiwiYXNKc29uIiwiYnVpbGRGb3JtYXR0ZXJzIiwic3RyaW5naWZ5IiwidmVyc2lvbiIsInJlZGFjdGlvbiIsImNvbnN0cnVjdG9yIiwiUGlubyIsInByb3RvdHlwZSIsImNoaWxkIiwiYmluZGluZ3MiLCJzZXRCaW5kaW5ncyIsImZsdXNoIiwibGV2ZWwiLCJsdmwiLCJsZXZlbFZhbCIsIm4iLCJFcnJvciIsIndyaXRlIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJtb2R1bGUiLCJleHBvcnRzIiwiY3JlYXRlIiwicmVzZXRDaGlsZGluZ3NGb3JtYXR0ZXIiLCJvcHRpb25zIiwic2VyaWFsaXplcnMiLCJmb3JtYXR0ZXJzIiwiaW5zdGFuY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImsiLCJwYXJlbnRTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsImtzIiwiYmsiLCJiaW5kaW5nc1N5bWJvbHMiLCJiaSIsImJrcyIsImNoaW5kaW5ncyIsImxvZyIsImxldmVscyIsImN1c3RvbUxldmVscyIsInJlZGFjdCIsIkFycmF5IiwiaXNBcnJheSIsInN0cmluZ2lmaWVycyIsImZvcm1hdE9wdHMiLCJtc2dQcmVmaXgiLCJjaGlsZExldmVsIiwib25DaGlsZCIsImNoaW5kaW5nc0pzb24iLCJzdWJzdHIiLCJiaW5kaW5nc0Zyb21Kc29uIiwiSlNPTiIsInBhcnNlIiwicGlkIiwiaG9zdG5hbWUiLCJuZXdCaW5kaW5ncyIsImRlZmF1bHRNaXhpbk1lcmdlU3RyYXRlZ3kiLCJtZXJnZU9iamVjdCIsIm1peGluT2JqZWN0IiwiYXNzaWduIiwiX29iaiIsIm1zZyIsIm51bSIsInQiLCJtaXhpbiIsImVycm9yS2V5IiwibWVzc2FnZUtleSIsIm1peGluTWVyZ2VTdHJhdGVneSIsIm9iaiIsInVuZGVmaW5lZCIsIm1lc3NhZ2UiLCJzIiwic3RyZWFtIiwibGFzdExldmVsIiwibGFzdE9iaiIsImxhc3RNc2ciLCJsYXN0VGltZSIsInNsaWNlIiwibGFzdExvZ2dlciIsIm5vb3AiLCJjYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/proto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/redaction.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/redaction.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst fastRedact = __webpack_require__(/*! fast-redact */ \"(rsc)/./node_modules/fast-redact/index.js\");\nconst { redactFmtSym, wildcardFirstSym } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/pino/lib/symbols.js\");\nconst { rx, validator } = fastRedact;\nconst validate = validator({\n    ERR_PATHS_MUST_BE_STRINGS: ()=>\"pino  redacted paths must be strings\",\n    ERR_INVALID_PATH: (s)=>`pino  redact paths array contains an invalid path (${s})`\n});\nconst CENSOR = \"[Redacted]\";\nconst strict = false // TODO should this be configurable?\n;\nfunction redaction(opts, serialize) {\n    const { paths, censor } = handle(opts);\n    const shape = paths.reduce((o, str)=>{\n        rx.lastIndex = 0;\n        const first = rx.exec(str);\n        const next = rx.exec(str);\n        // ns is the top-level path segment, brackets + quoting removed.\n        let ns = first[1] !== undefined ? first[1].replace(/^(?:\"|'|`)(.*)(?:\"|'|`)$/, \"$1\") : first[0];\n        if (ns === \"*\") {\n            ns = wildcardFirstSym;\n        }\n        // top level key:\n        if (next === null) {\n            o[ns] = null;\n            return o;\n        }\n        // path with at least two segments:\n        // if ns is already redacted at the top level, ignore lower level redactions\n        if (o[ns] === null) {\n            return o;\n        }\n        const { index } = next;\n        const nextPath = `${str.substr(index, str.length - 1)}`;\n        o[ns] = o[ns] || [];\n        // shape is a mix of paths beginning with literal values and wildcard\n        // paths [ \"a.b.c\", \"*.b.z\" ] should reduce to a shape of\n        // { \"a\": [ \"b.c\", \"b.z\" ], *: [ \"b.z\" ] }\n        // note: \"b.z\" is in both \"a\" and * arrays because \"a\" matches the wildcard.\n        // (* entry has wildcardFirstSym as key)\n        if (ns !== wildcardFirstSym && o[ns].length === 0) {\n            // first time ns's get all '*' redactions so far\n            o[ns].push(...o[wildcardFirstSym] || []);\n        }\n        if (ns === wildcardFirstSym) {\n            // new * path gets added to all previously registered literal ns's.\n            Object.keys(o).forEach(function(k) {\n                if (o[k]) {\n                    o[k].push(nextPath);\n                }\n            });\n        }\n        o[ns].push(nextPath);\n        return o;\n    }, {});\n    // the redactor assigned to the format symbol key\n    // provides top level redaction for instances where\n    // an object is interpolated into the msg string\n    const result = {\n        [redactFmtSym]: fastRedact({\n            paths,\n            censor,\n            serialize,\n            strict\n        })\n    };\n    const topCensor = (...args)=>{\n        return typeof censor === \"function\" ? serialize(censor(...args)) : serialize(censor);\n    };\n    return [\n        ...Object.keys(shape),\n        ...Object.getOwnPropertySymbols(shape)\n    ].reduce((o, k)=>{\n        // top level key:\n        if (shape[k] === null) {\n            o[k] = (value)=>topCensor(value, [\n                    k\n                ]);\n        } else {\n            const wrappedCensor = typeof censor === \"function\" ? (value, path)=>{\n                return censor(value, [\n                    k,\n                    ...path\n                ]);\n            } : censor;\n            o[k] = fastRedact({\n                paths: shape[k],\n                censor: wrappedCensor,\n                serialize,\n                strict\n            });\n        }\n        return o;\n    }, result);\n}\nfunction handle(opts) {\n    if (Array.isArray(opts)) {\n        opts = {\n            paths: opts,\n            censor: CENSOR\n        };\n        validate(opts);\n        return opts;\n    }\n    let { paths, censor = CENSOR, remove } = opts;\n    if (Array.isArray(paths) === false) {\n        throw Error(\"pino  redact must contain an array of strings\");\n    }\n    if (remove === true) censor = undefined;\n    validate({\n        paths,\n        censor\n    });\n    return {\n        paths,\n        censor\n    };\n}\nmodule.exports = redaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvcmVkYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFQyxZQUFZLEVBQUVDLGdCQUFnQixFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ25ELE1BQU0sRUFBRUcsRUFBRSxFQUFFQyxTQUFTLEVBQUUsR0FBR0w7QUFFMUIsTUFBTU0sV0FBV0QsVUFBVTtJQUN6QkUsMkJBQTJCLElBQU07SUFDakNDLGtCQUFrQixDQUFDQyxJQUFNLENBQUMsb0RBQW9ELEVBQUVBLEVBQUUsQ0FBQyxDQUFDO0FBQ3RGO0FBRUEsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFNBQVMsTUFBTSxvQ0FBb0M7O0FBRXpELFNBQVNDLFVBQVdDLElBQUksRUFBRUMsU0FBUztJQUNqQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdDLE9BQU9KO0lBRWpDLE1BQU1LLFFBQVFILE1BQU1JLE1BQU0sQ0FBQyxDQUFDQyxHQUFHQztRQUM3QmpCLEdBQUdrQixTQUFTLEdBQUc7UUFDZixNQUFNQyxRQUFRbkIsR0FBR29CLElBQUksQ0FBQ0g7UUFDdEIsTUFBTUksT0FBT3JCLEdBQUdvQixJQUFJLENBQUNIO1FBRXJCLGdFQUFnRTtRQUNoRSxJQUFJSyxLQUFLSCxLQUFLLENBQUMsRUFBRSxLQUFLSSxZQUNsQkosS0FBSyxDQUFDLEVBQUUsQ0FBQ0ssT0FBTyxDQUFDLDRCQUE0QixRQUM3Q0wsS0FBSyxDQUFDLEVBQUU7UUFFWixJQUFJRyxPQUFPLEtBQUs7WUFDZEEsS0FBS3ZCO1FBQ1A7UUFFQSxpQkFBaUI7UUFDakIsSUFBSXNCLFNBQVMsTUFBTTtZQUNqQkwsQ0FBQyxDQUFDTSxHQUFHLEdBQUc7WUFDUixPQUFPTjtRQUNUO1FBRUEsbUNBQW1DO1FBQ25DLDRFQUE0RTtRQUM1RSxJQUFJQSxDQUFDLENBQUNNLEdBQUcsS0FBSyxNQUFNO1lBQ2xCLE9BQU9OO1FBQ1Q7UUFFQSxNQUFNLEVBQUVTLEtBQUssRUFBRSxHQUFHSjtRQUNsQixNQUFNSyxXQUFXLENBQUMsRUFBRVQsSUFBSVUsTUFBTSxDQUFDRixPQUFPUixJQUFJVyxNQUFNLEdBQUcsR0FBRyxDQUFDO1FBRXZEWixDQUFDLENBQUNNLEdBQUcsR0FBR04sQ0FBQyxDQUFDTSxHQUFHLElBQUksRUFBRTtRQUVuQixxRUFBcUU7UUFDckUseURBQXlEO1FBQ3pELDBDQUEwQztRQUMxQyw0RUFBNEU7UUFDNUUsd0NBQXdDO1FBQ3hDLElBQUlBLE9BQU92QixvQkFBb0JpQixDQUFDLENBQUNNLEdBQUcsQ0FBQ00sTUFBTSxLQUFLLEdBQUc7WUFDakQsZ0RBQWdEO1lBQ2hEWixDQUFDLENBQUNNLEdBQUcsQ0FBQ08sSUFBSSxJQUFLYixDQUFDLENBQUNqQixpQkFBaUIsSUFBSSxFQUFFO1FBQzFDO1FBRUEsSUFBSXVCLE9BQU92QixrQkFBa0I7WUFDM0IsbUVBQW1FO1lBQ25FK0IsT0FBT0MsSUFBSSxDQUFDZixHQUFHZ0IsT0FBTyxDQUFDLFNBQVVDLENBQUM7Z0JBQ2hDLElBQUlqQixDQUFDLENBQUNpQixFQUFFLEVBQUU7b0JBQ1JqQixDQUFDLENBQUNpQixFQUFFLENBQUNKLElBQUksQ0FBQ0g7Z0JBQ1o7WUFDRjtRQUNGO1FBRUFWLENBQUMsQ0FBQ00sR0FBRyxDQUFDTyxJQUFJLENBQUNIO1FBQ1gsT0FBT1Y7SUFDVCxHQUFHLENBQUM7SUFFSixpREFBaUQ7SUFDakQsbURBQW1EO0lBQ25ELGdEQUFnRDtJQUNoRCxNQUFNa0IsU0FBUztRQUNiLENBQUNwQyxhQUFhLEVBQUVGLFdBQVc7WUFBRWU7WUFBT0M7WUFBUUY7WUFBV0g7UUFBTztJQUNoRTtJQUVBLE1BQU00QixZQUFZLENBQUMsR0FBR0M7UUFDcEIsT0FBTyxPQUFPeEIsV0FBVyxhQUFhRixVQUFVRSxVQUFVd0IsU0FBUzFCLFVBQVVFO0lBQy9FO0lBRUEsT0FBTztXQUFJa0IsT0FBT0MsSUFBSSxDQUFDakI7V0FBV2dCLE9BQU9PLHFCQUFxQixDQUFDdkI7S0FBTyxDQUFDQyxNQUFNLENBQUMsQ0FBQ0MsR0FBR2lCO1FBQ2hGLGlCQUFpQjtRQUNqQixJQUFJbkIsS0FBSyxDQUFDbUIsRUFBRSxLQUFLLE1BQU07WUFDckJqQixDQUFDLENBQUNpQixFQUFFLEdBQUcsQ0FBQ0ssUUFBVUgsVUFBVUcsT0FBTztvQkFBQ0w7aUJBQUU7UUFDeEMsT0FBTztZQUNMLE1BQU1NLGdCQUFnQixPQUFPM0IsV0FBVyxhQUNwQyxDQUFDMEIsT0FBT0U7Z0JBQ04sT0FBTzVCLE9BQU8wQixPQUFPO29CQUFDTDt1QkFBTU87aUJBQUs7WUFDbkMsSUFDQTVCO1lBQ0pJLENBQUMsQ0FBQ2lCLEVBQUUsR0FBR3JDLFdBQVc7Z0JBQ2hCZSxPQUFPRyxLQUFLLENBQUNtQixFQUFFO2dCQUNmckIsUUFBUTJCO2dCQUNSN0I7Z0JBQ0FIO1lBQ0Y7UUFDRjtRQUNBLE9BQU9TO0lBQ1QsR0FBR2tCO0FBQ0w7QUFFQSxTQUFTckIsT0FBUUosSUFBSTtJQUNuQixJQUFJZ0MsTUFBTUMsT0FBTyxDQUFDakMsT0FBTztRQUN2QkEsT0FBTztZQUFFRSxPQUFPRjtZQUFNRyxRQUFRTjtRQUFPO1FBQ3JDSixTQUFTTztRQUNULE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLEVBQUVFLEtBQUssRUFBRUMsU0FBU04sTUFBTSxFQUFFcUMsTUFBTSxFQUFFLEdBQUdsQztJQUN6QyxJQUFJZ0MsTUFBTUMsT0FBTyxDQUFDL0IsV0FBVyxPQUFPO1FBQUUsTUFBTWlDLE1BQU07SUFBa0Q7SUFDcEcsSUFBSUQsV0FBVyxNQUFNL0IsU0FBU1c7SUFDOUJyQixTQUFTO1FBQUVTO1FBQU9DO0lBQU87SUFFekIsT0FBTztRQUFFRDtRQUFPQztJQUFPO0FBQ3pCO0FBRUFpQyxPQUFPQyxPQUFPLEdBQUd0QyIsInNvdXJjZXMiOlsid2VicGFjazovL25lY3Rhci1hZG1pbi12MS8uL25vZGVfbW9kdWxlcy9waW5vL2xpYi9yZWRhY3Rpb24uanM/Yzg0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZmFzdFJlZGFjdCA9IHJlcXVpcmUoJ2Zhc3QtcmVkYWN0JylcbmNvbnN0IHsgcmVkYWN0Rm10U3ltLCB3aWxkY2FyZEZpcnN0U3ltIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyByeCwgdmFsaWRhdG9yIH0gPSBmYXN0UmVkYWN0XG5cbmNvbnN0IHZhbGlkYXRlID0gdmFsaWRhdG9yKHtcbiAgRVJSX1BBVEhTX01VU1RfQkVfU1RSSU5HUzogKCkgPT4gJ3Bpbm8g4oCTIHJlZGFjdGVkIHBhdGhzIG11c3QgYmUgc3RyaW5ncycsXG4gIEVSUl9JTlZBTElEX1BBVEg6IChzKSA9PiBgcGlubyDigJMgcmVkYWN0IHBhdGhzIGFycmF5IGNvbnRhaW5zIGFuIGludmFsaWQgcGF0aCAoJHtzfSlgXG59KVxuXG5jb25zdCBDRU5TT1IgPSAnW1JlZGFjdGVkXSdcbmNvbnN0IHN0cmljdCA9IGZhbHNlIC8vIFRPRE8gc2hvdWxkIHRoaXMgYmUgY29uZmlndXJhYmxlP1xuXG5mdW5jdGlvbiByZWRhY3Rpb24gKG9wdHMsIHNlcmlhbGl6ZSkge1xuICBjb25zdCB7IHBhdGhzLCBjZW5zb3IgfSA9IGhhbmRsZShvcHRzKVxuXG4gIGNvbnN0IHNoYXBlID0gcGF0aHMucmVkdWNlKChvLCBzdHIpID0+IHtcbiAgICByeC5sYXN0SW5kZXggPSAwXG4gICAgY29uc3QgZmlyc3QgPSByeC5leGVjKHN0cilcbiAgICBjb25zdCBuZXh0ID0gcnguZXhlYyhzdHIpXG5cbiAgICAvLyBucyBpcyB0aGUgdG9wLWxldmVsIHBhdGggc2VnbWVudCwgYnJhY2tldHMgKyBxdW90aW5nIHJlbW92ZWQuXG4gICAgbGV0IG5zID0gZmlyc3RbMV0gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmaXJzdFsxXS5yZXBsYWNlKC9eKD86XCJ8J3xgKSguKikoPzpcInwnfGApJC8sICckMScpXG4gICAgICA6IGZpcnN0WzBdXG5cbiAgICBpZiAobnMgPT09ICcqJykge1xuICAgICAgbnMgPSB3aWxkY2FyZEZpcnN0U3ltXG4gICAgfVxuXG4gICAgLy8gdG9wIGxldmVsIGtleTpcbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgb1tuc10gPSBudWxsXG4gICAgICByZXR1cm4gb1xuICAgIH1cblxuICAgIC8vIHBhdGggd2l0aCBhdCBsZWFzdCB0d28gc2VnbWVudHM6XG4gICAgLy8gaWYgbnMgaXMgYWxyZWFkeSByZWRhY3RlZCBhdCB0aGUgdG9wIGxldmVsLCBpZ25vcmUgbG93ZXIgbGV2ZWwgcmVkYWN0aW9uc1xuICAgIGlmIChvW25zXSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9cbiAgICB9XG5cbiAgICBjb25zdCB7IGluZGV4IH0gPSBuZXh0XG4gICAgY29uc3QgbmV4dFBhdGggPSBgJHtzdHIuc3Vic3RyKGluZGV4LCBzdHIubGVuZ3RoIC0gMSl9YFxuXG4gICAgb1tuc10gPSBvW25zXSB8fCBbXVxuXG4gICAgLy8gc2hhcGUgaXMgYSBtaXggb2YgcGF0aHMgYmVnaW5uaW5nIHdpdGggbGl0ZXJhbCB2YWx1ZXMgYW5kIHdpbGRjYXJkXG4gICAgLy8gcGF0aHMgWyBcImEuYi5jXCIsIFwiKi5iLnpcIiBdIHNob3VsZCByZWR1Y2UgdG8gYSBzaGFwZSBvZlxuICAgIC8vIHsgXCJhXCI6IFsgXCJiLmNcIiwgXCJiLnpcIiBdLCAqOiBbIFwiYi56XCIgXSB9XG4gICAgLy8gbm90ZTogXCJiLnpcIiBpcyBpbiBib3RoIFwiYVwiIGFuZCAqIGFycmF5cyBiZWNhdXNlIFwiYVwiIG1hdGNoZXMgdGhlIHdpbGRjYXJkLlxuICAgIC8vICgqIGVudHJ5IGhhcyB3aWxkY2FyZEZpcnN0U3ltIGFzIGtleSlcbiAgICBpZiAobnMgIT09IHdpbGRjYXJkRmlyc3RTeW0gJiYgb1tuc10ubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIG5zJ3MgZ2V0IGFsbCAnKicgcmVkYWN0aW9ucyBzbyBmYXJcbiAgICAgIG9bbnNdLnB1c2goLi4uKG9bd2lsZGNhcmRGaXJzdFN5bV0gfHwgW10pKVxuICAgIH1cblxuICAgIGlmIChucyA9PT0gd2lsZGNhcmRGaXJzdFN5bSkge1xuICAgICAgLy8gbmV3ICogcGF0aCBnZXRzIGFkZGVkIHRvIGFsbCBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgbGl0ZXJhbCBucydzLlxuICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAob1trXSkge1xuICAgICAgICAgIG9ba10ucHVzaChuZXh0UGF0aClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBvW25zXS5wdXNoKG5leHRQYXRoKVxuICAgIHJldHVybiBvXG4gIH0sIHt9KVxuXG4gIC8vIHRoZSByZWRhY3RvciBhc3NpZ25lZCB0byB0aGUgZm9ybWF0IHN5bWJvbCBrZXlcbiAgLy8gcHJvdmlkZXMgdG9wIGxldmVsIHJlZGFjdGlvbiBmb3IgaW5zdGFuY2VzIHdoZXJlXG4gIC8vIGFuIG9iamVjdCBpcyBpbnRlcnBvbGF0ZWQgaW50byB0aGUgbXNnIHN0cmluZ1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgW3JlZGFjdEZtdFN5bV06IGZhc3RSZWRhY3QoeyBwYXRocywgY2Vuc29yLCBzZXJpYWxpemUsIHN0cmljdCB9KVxuICB9XG5cbiAgY29uc3QgdG9wQ2Vuc29yID0gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGNlbnNvciA9PT0gJ2Z1bmN0aW9uJyA/IHNlcmlhbGl6ZShjZW5zb3IoLi4uYXJncykpIDogc2VyaWFsaXplKGNlbnNvcilcbiAgfVxuXG4gIHJldHVybiBbLi4uT2JqZWN0LmtleXMoc2hhcGUpLCAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNoYXBlKV0ucmVkdWNlKChvLCBrKSA9PiB7XG4gICAgLy8gdG9wIGxldmVsIGtleTpcbiAgICBpZiAoc2hhcGVba10gPT09IG51bGwpIHtcbiAgICAgIG9ba10gPSAodmFsdWUpID0+IHRvcENlbnNvcih2YWx1ZSwgW2tdKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cmFwcGVkQ2Vuc29yID0gdHlwZW9mIGNlbnNvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/ICh2YWx1ZSwgcGF0aCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNlbnNvcih2YWx1ZSwgW2ssIC4uLnBhdGhdKVxuICAgICAgICAgIH1cbiAgICAgICAgOiBjZW5zb3JcbiAgICAgIG9ba10gPSBmYXN0UmVkYWN0KHtcbiAgICAgICAgcGF0aHM6IHNoYXBlW2tdLFxuICAgICAgICBjZW5zb3I6IHdyYXBwZWRDZW5zb3IsXG4gICAgICAgIHNlcmlhbGl6ZSxcbiAgICAgICAgc3RyaWN0XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gb1xuICB9LCByZXN1bHQpXG59XG5cbmZ1bmN0aW9uIGhhbmRsZSAob3B0cykge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgIG9wdHMgPSB7IHBhdGhzOiBvcHRzLCBjZW5zb3I6IENFTlNPUiB9XG4gICAgdmFsaWRhdGUob3B0cylcbiAgICByZXR1cm4gb3B0c1xuICB9XG4gIGxldCB7IHBhdGhzLCBjZW5zb3IgPSBDRU5TT1IsIHJlbW92ZSB9ID0gb3B0c1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRocykgPT09IGZhbHNlKSB7IHRocm93IEVycm9yKCdwaW5vIOKAkyByZWRhY3QgbXVzdCBjb250YWluIGFuIGFycmF5IG9mIHN0cmluZ3MnKSB9XG4gIGlmIChyZW1vdmUgPT09IHRydWUpIGNlbnNvciA9IHVuZGVmaW5lZFxuICB2YWxpZGF0ZSh7IHBhdGhzLCBjZW5zb3IgfSlcblxuICByZXR1cm4geyBwYXRocywgY2Vuc29yIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWRhY3Rpb25cbiJdLCJuYW1lcyI6WyJmYXN0UmVkYWN0IiwicmVxdWlyZSIsInJlZGFjdEZtdFN5bSIsIndpbGRjYXJkRmlyc3RTeW0iLCJyeCIsInZhbGlkYXRvciIsInZhbGlkYXRlIiwiRVJSX1BBVEhTX01VU1RfQkVfU1RSSU5HUyIsIkVSUl9JTlZBTElEX1BBVEgiLCJzIiwiQ0VOU09SIiwic3RyaWN0IiwicmVkYWN0aW9uIiwib3B0cyIsInNlcmlhbGl6ZSIsInBhdGhzIiwiY2Vuc29yIiwiaGFuZGxlIiwic2hhcGUiLCJyZWR1Y2UiLCJvIiwic3RyIiwibGFzdEluZGV4IiwiZmlyc3QiLCJleGVjIiwibmV4dCIsIm5zIiwidW5kZWZpbmVkIiwicmVwbGFjZSIsImluZGV4IiwibmV4dFBhdGgiLCJzdWJzdHIiLCJsZW5ndGgiLCJwdXNoIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrIiwicmVzdWx0IiwidG9wQ2Vuc29yIiwiYXJncyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInZhbHVlIiwid3JhcHBlZENlbnNvciIsInBhdGgiLCJBcnJheSIsImlzQXJyYXkiLCJyZW1vdmUiLCJFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/redaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/symbols.js":
/*!******************************************!*\
  !*** ./node_modules/pino/lib/symbols.js ***!
  \******************************************/
/***/ ((module) => {

eval("\nconst setLevelSym = Symbol(\"pino.setLevel\");\nconst getLevelSym = Symbol(\"pino.getLevel\");\nconst levelValSym = Symbol(\"pino.levelVal\");\nconst levelCompSym = Symbol(\"pino.levelComp\");\nconst useLevelLabelsSym = Symbol(\"pino.useLevelLabels\");\nconst useOnlyCustomLevelsSym = Symbol(\"pino.useOnlyCustomLevels\");\nconst mixinSym = Symbol(\"pino.mixin\");\nconst lsCacheSym = Symbol(\"pino.lsCache\");\nconst chindingsSym = Symbol(\"pino.chindings\");\nconst asJsonSym = Symbol(\"pino.asJson\");\nconst writeSym = Symbol(\"pino.write\");\nconst redactFmtSym = Symbol(\"pino.redactFmt\");\nconst timeSym = Symbol(\"pino.time\");\nconst timeSliceIndexSym = Symbol(\"pino.timeSliceIndex\");\nconst streamSym = Symbol(\"pino.stream\");\nconst stringifySym = Symbol(\"pino.stringify\");\nconst stringifySafeSym = Symbol(\"pino.stringifySafe\");\nconst stringifiersSym = Symbol(\"pino.stringifiers\");\nconst endSym = Symbol(\"pino.end\");\nconst formatOptsSym = Symbol(\"pino.formatOpts\");\nconst messageKeySym = Symbol(\"pino.messageKey\");\nconst errorKeySym = Symbol(\"pino.errorKey\");\nconst nestedKeySym = Symbol(\"pino.nestedKey\");\nconst nestedKeyStrSym = Symbol(\"pino.nestedKeyStr\");\nconst mixinMergeStrategySym = Symbol(\"pino.mixinMergeStrategy\");\nconst msgPrefixSym = Symbol(\"pino.msgPrefix\");\nconst wildcardFirstSym = Symbol(\"pino.wildcardFirst\");\n// public symbols, no need to use the same pino\n// version for these\nconst serializersSym = Symbol.for(\"pino.serializers\");\nconst formattersSym = Symbol.for(\"pino.formatters\");\nconst hooksSym = Symbol.for(\"pino.hooks\");\nconst needsMetadataGsym = Symbol.for(\"pino.metadata\");\nmodule.exports = {\n    setLevelSym,\n    getLevelSym,\n    levelValSym,\n    levelCompSym,\n    useLevelLabelsSym,\n    mixinSym,\n    lsCacheSym,\n    chindingsSym,\n    asJsonSym,\n    writeSym,\n    serializersSym,\n    redactFmtSym,\n    timeSym,\n    timeSliceIndexSym,\n    streamSym,\n    stringifySym,\n    stringifySafeSym,\n    stringifiersSym,\n    endSym,\n    formatOptsSym,\n    messageKeySym,\n    errorKeySym,\n    nestedKeySym,\n    wildcardFirstSym,\n    needsMetadataGsym,\n    useOnlyCustomLevelsSym,\n    formattersSym,\n    hooksSym,\n    nestedKeyStrSym,\n    mixinMergeStrategySym,\n    msgPrefixSym\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGNBQWNDLE9BQU87QUFDM0IsTUFBTUMsY0FBY0QsT0FBTztBQUMzQixNQUFNRSxjQUFjRixPQUFPO0FBQzNCLE1BQU1HLGVBQWVILE9BQU87QUFDNUIsTUFBTUksb0JBQW9CSixPQUFPO0FBQ2pDLE1BQU1LLHlCQUF5QkwsT0FBTztBQUN0QyxNQUFNTSxXQUFXTixPQUFPO0FBRXhCLE1BQU1PLGFBQWFQLE9BQU87QUFDMUIsTUFBTVEsZUFBZVIsT0FBTztBQUU1QixNQUFNUyxZQUFZVCxPQUFPO0FBQ3pCLE1BQU1VLFdBQVdWLE9BQU87QUFDeEIsTUFBTVcsZUFBZVgsT0FBTztBQUU1QixNQUFNWSxVQUFVWixPQUFPO0FBQ3ZCLE1BQU1hLG9CQUFvQmIsT0FBTztBQUNqQyxNQUFNYyxZQUFZZCxPQUFPO0FBQ3pCLE1BQU1lLGVBQWVmLE9BQU87QUFDNUIsTUFBTWdCLG1CQUFtQmhCLE9BQU87QUFDaEMsTUFBTWlCLGtCQUFrQmpCLE9BQU87QUFDL0IsTUFBTWtCLFNBQVNsQixPQUFPO0FBQ3RCLE1BQU1tQixnQkFBZ0JuQixPQUFPO0FBQzdCLE1BQU1vQixnQkFBZ0JwQixPQUFPO0FBQzdCLE1BQU1xQixjQUFjckIsT0FBTztBQUMzQixNQUFNc0IsZUFBZXRCLE9BQU87QUFDNUIsTUFBTXVCLGtCQUFrQnZCLE9BQU87QUFDL0IsTUFBTXdCLHdCQUF3QnhCLE9BQU87QUFDckMsTUFBTXlCLGVBQWV6QixPQUFPO0FBRTVCLE1BQU0wQixtQkFBbUIxQixPQUFPO0FBRWhDLCtDQUErQztBQUMvQyxvQkFBb0I7QUFDcEIsTUFBTTJCLGlCQUFpQjNCLE9BQU80QixHQUFHLENBQUM7QUFDbEMsTUFBTUMsZ0JBQWdCN0IsT0FBTzRCLEdBQUcsQ0FBQztBQUNqQyxNQUFNRSxXQUFXOUIsT0FBTzRCLEdBQUcsQ0FBQztBQUM1QixNQUFNRyxvQkFBb0IvQixPQUFPNEIsR0FBRyxDQUFDO0FBRXJDSSxPQUFPQyxPQUFPLEdBQUc7SUFDZmxDO0lBQ0FFO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FFO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FpQjtJQUNBaEI7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUk7SUFDQUs7SUFDQTFCO0lBQ0F3QjtJQUNBQztJQUNBUDtJQUNBQztJQUNBQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVjdGFyLWFkbWluLXYxLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL3N5bWJvbHMuanM/N2UwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qgc2V0TGV2ZWxTeW0gPSBTeW1ib2woJ3Bpbm8uc2V0TGV2ZWwnKVxuY29uc3QgZ2V0TGV2ZWxTeW0gPSBTeW1ib2woJ3Bpbm8uZ2V0TGV2ZWwnKVxuY29uc3QgbGV2ZWxWYWxTeW0gPSBTeW1ib2woJ3Bpbm8ubGV2ZWxWYWwnKVxuY29uc3QgbGV2ZWxDb21wU3ltID0gU3ltYm9sKCdwaW5vLmxldmVsQ29tcCcpXG5jb25zdCB1c2VMZXZlbExhYmVsc1N5bSA9IFN5bWJvbCgncGluby51c2VMZXZlbExhYmVscycpXG5jb25zdCB1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltID0gU3ltYm9sKCdwaW5vLnVzZU9ubHlDdXN0b21MZXZlbHMnKVxuY29uc3QgbWl4aW5TeW0gPSBTeW1ib2woJ3Bpbm8ubWl4aW4nKVxuXG5jb25zdCBsc0NhY2hlU3ltID0gU3ltYm9sKCdwaW5vLmxzQ2FjaGUnKVxuY29uc3QgY2hpbmRpbmdzU3ltID0gU3ltYm9sKCdwaW5vLmNoaW5kaW5ncycpXG5cbmNvbnN0IGFzSnNvblN5bSA9IFN5bWJvbCgncGluby5hc0pzb24nKVxuY29uc3Qgd3JpdGVTeW0gPSBTeW1ib2woJ3Bpbm8ud3JpdGUnKVxuY29uc3QgcmVkYWN0Rm10U3ltID0gU3ltYm9sKCdwaW5vLnJlZGFjdEZtdCcpXG5cbmNvbnN0IHRpbWVTeW0gPSBTeW1ib2woJ3Bpbm8udGltZScpXG5jb25zdCB0aW1lU2xpY2VJbmRleFN5bSA9IFN5bWJvbCgncGluby50aW1lU2xpY2VJbmRleCcpXG5jb25zdCBzdHJlYW1TeW0gPSBTeW1ib2woJ3Bpbm8uc3RyZWFtJylcbmNvbnN0IHN0cmluZ2lmeVN5bSA9IFN5bWJvbCgncGluby5zdHJpbmdpZnknKVxuY29uc3Qgc3RyaW5naWZ5U2FmZVN5bSA9IFN5bWJvbCgncGluby5zdHJpbmdpZnlTYWZlJylcbmNvbnN0IHN0cmluZ2lmaWVyc1N5bSA9IFN5bWJvbCgncGluby5zdHJpbmdpZmllcnMnKVxuY29uc3QgZW5kU3ltID0gU3ltYm9sKCdwaW5vLmVuZCcpXG5jb25zdCBmb3JtYXRPcHRzU3ltID0gU3ltYm9sKCdwaW5vLmZvcm1hdE9wdHMnKVxuY29uc3QgbWVzc2FnZUtleVN5bSA9IFN5bWJvbCgncGluby5tZXNzYWdlS2V5JylcbmNvbnN0IGVycm9yS2V5U3ltID0gU3ltYm9sKCdwaW5vLmVycm9yS2V5JylcbmNvbnN0IG5lc3RlZEtleVN5bSA9IFN5bWJvbCgncGluby5uZXN0ZWRLZXknKVxuY29uc3QgbmVzdGVkS2V5U3RyU3ltID0gU3ltYm9sKCdwaW5vLm5lc3RlZEtleVN0cicpXG5jb25zdCBtaXhpbk1lcmdlU3RyYXRlZ3lTeW0gPSBTeW1ib2woJ3Bpbm8ubWl4aW5NZXJnZVN0cmF0ZWd5JylcbmNvbnN0IG1zZ1ByZWZpeFN5bSA9IFN5bWJvbCgncGluby5tc2dQcmVmaXgnKVxuXG5jb25zdCB3aWxkY2FyZEZpcnN0U3ltID0gU3ltYm9sKCdwaW5vLndpbGRjYXJkRmlyc3QnKVxuXG4vLyBwdWJsaWMgc3ltYm9scywgbm8gbmVlZCB0byB1c2UgdGhlIHNhbWUgcGlub1xuLy8gdmVyc2lvbiBmb3IgdGhlc2VcbmNvbnN0IHNlcmlhbGl6ZXJzU3ltID0gU3ltYm9sLmZvcigncGluby5zZXJpYWxpemVycycpXG5jb25zdCBmb3JtYXR0ZXJzU3ltID0gU3ltYm9sLmZvcigncGluby5mb3JtYXR0ZXJzJylcbmNvbnN0IGhvb2tzU3ltID0gU3ltYm9sLmZvcigncGluby5ob29rcycpXG5jb25zdCBuZWVkc01ldGFkYXRhR3N5bSA9IFN5bWJvbC5mb3IoJ3Bpbm8ubWV0YWRhdGEnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0TGV2ZWxTeW0sXG4gIGdldExldmVsU3ltLFxuICBsZXZlbFZhbFN5bSxcbiAgbGV2ZWxDb21wU3ltLFxuICB1c2VMZXZlbExhYmVsc1N5bSxcbiAgbWl4aW5TeW0sXG4gIGxzQ2FjaGVTeW0sXG4gIGNoaW5kaW5nc1N5bSxcbiAgYXNKc29uU3ltLFxuICB3cml0ZVN5bSxcbiAgc2VyaWFsaXplcnNTeW0sXG4gIHJlZGFjdEZtdFN5bSxcbiAgdGltZVN5bSxcbiAgdGltZVNsaWNlSW5kZXhTeW0sXG4gIHN0cmVhbVN5bSxcbiAgc3RyaW5naWZ5U3ltLFxuICBzdHJpbmdpZnlTYWZlU3ltLFxuICBzdHJpbmdpZmllcnNTeW0sXG4gIGVuZFN5bSxcbiAgZm9ybWF0T3B0c1N5bSxcbiAgbWVzc2FnZUtleVN5bSxcbiAgZXJyb3JLZXlTeW0sXG4gIG5lc3RlZEtleVN5bSxcbiAgd2lsZGNhcmRGaXJzdFN5bSxcbiAgbmVlZHNNZXRhZGF0YUdzeW0sXG4gIHVzZU9ubHlDdXN0b21MZXZlbHNTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIGhvb2tzU3ltLFxuICBuZXN0ZWRLZXlTdHJTeW0sXG4gIG1peGluTWVyZ2VTdHJhdGVneVN5bSxcbiAgbXNnUHJlZml4U3ltXG59XG4iXSwibmFtZXMiOlsic2V0TGV2ZWxTeW0iLCJTeW1ib2wiLCJnZXRMZXZlbFN5bSIsImxldmVsVmFsU3ltIiwibGV2ZWxDb21wU3ltIiwidXNlTGV2ZWxMYWJlbHNTeW0iLCJ1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltIiwibWl4aW5TeW0iLCJsc0NhY2hlU3ltIiwiY2hpbmRpbmdzU3ltIiwiYXNKc29uU3ltIiwid3JpdGVTeW0iLCJyZWRhY3RGbXRTeW0iLCJ0aW1lU3ltIiwidGltZVNsaWNlSW5kZXhTeW0iLCJzdHJlYW1TeW0iLCJzdHJpbmdpZnlTeW0iLCJzdHJpbmdpZnlTYWZlU3ltIiwic3RyaW5naWZpZXJzU3ltIiwiZW5kU3ltIiwiZm9ybWF0T3B0c1N5bSIsIm1lc3NhZ2VLZXlTeW0iLCJlcnJvcktleVN5bSIsIm5lc3RlZEtleVN5bSIsIm5lc3RlZEtleVN0clN5bSIsIm1peGluTWVyZ2VTdHJhdGVneVN5bSIsIm1zZ1ByZWZpeFN5bSIsIndpbGRjYXJkRmlyc3RTeW0iLCJzZXJpYWxpemVyc1N5bSIsImZvciIsImZvcm1hdHRlcnNTeW0iLCJob29rc1N5bSIsIm5lZWRzTWV0YWRhdGFHc3ltIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/time.js":
/*!***************************************!*\
  !*** ./node_modules/pino/lib/time.js ***!
  \***************************************/
/***/ ((module) => {

eval("\nconst nullTime = ()=>\"\";\nconst epochTime = ()=>`,\"time\":${Date.now()}`;\nconst unixTime = ()=>`,\"time\":${Math.round(Date.now() / 1000.0)}`;\nconst isoTime = ()=>`,\"time\":\"${new Date(Date.now()).toISOString()}\"` // using Date.now() for testability\n;\nmodule.exports = {\n    nullTime,\n    epochTime,\n    unixTime,\n    isoTime\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFdBQVcsSUFBTTtBQUV2QixNQUFNQyxZQUFZLElBQU0sQ0FBQyxRQUFRLEVBQUVDLEtBQUtDLEdBQUcsR0FBRyxDQUFDO0FBRS9DLE1BQU1DLFdBQVcsSUFBTSxDQUFDLFFBQVEsRUFBRUMsS0FBS0MsS0FBSyxDQUFDSixLQUFLQyxHQUFHLEtBQUssUUFBUSxDQUFDO0FBRW5FLE1BQU1JLFVBQVUsSUFBTSxDQUFDLFNBQVMsRUFBRSxJQUFJTCxLQUFLQSxLQUFLQyxHQUFHLElBQUlLLFdBQVcsR0FBRyxDQUFDLENBQUMsQ0FBQyxtQ0FBbUM7O0FBRTNHQyxPQUFPQyxPQUFPLEdBQUc7SUFBRVY7SUFBVUM7SUFBV0c7SUFBVUc7QUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL25lY3Rhci1hZG1pbi12MS8uL25vZGVfbW9kdWxlcy9waW5vL2xpYi90aW1lLmpzPzQxMzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG51bGxUaW1lID0gKCkgPT4gJydcblxuY29uc3QgZXBvY2hUaW1lID0gKCkgPT4gYCxcInRpbWVcIjoke0RhdGUubm93KCl9YFxuXG5jb25zdCB1bml4VGltZSA9ICgpID0+IGAsXCJ0aW1lXCI6JHtNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwLjApfWBcblxuY29uc3QgaXNvVGltZSA9ICgpID0+IGAsXCJ0aW1lXCI6XCIke25ldyBEYXRlKERhdGUubm93KCkpLnRvSVNPU3RyaW5nKCl9XCJgIC8vIHVzaW5nIERhdGUubm93KCkgZm9yIHRlc3RhYmlsaXR5XG5cbm1vZHVsZS5leHBvcnRzID0geyBudWxsVGltZSwgZXBvY2hUaW1lLCB1bml4VGltZSwgaXNvVGltZSB9XG4iXSwibmFtZXMiOlsibnVsbFRpbWUiLCJlcG9jaFRpbWUiLCJEYXRlIiwibm93IiwidW5peFRpbWUiLCJNYXRoIiwicm91bmQiLCJpc29UaW1lIiwidG9JU09TdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/time.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/tools.js":
/*!****************************************!*\
  !*** ./node_modules/pino/lib/tools.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/* eslint no-prototype-builtins: 0 */ const format = __webpack_require__(/*! quick-format-unescaped */ \"(rsc)/./node_modules/quick-format-unescaped/index.js\");\nconst { mapHttpRequest, mapHttpResponse } = __webpack_require__(/*! pino-std-serializers */ \"(rsc)/./node_modules/pino-std-serializers/index.js\");\nconst SonicBoom = __webpack_require__(/*! sonic-boom */ \"(rsc)/./node_modules/sonic-boom/index.js\");\nconst onExit = __webpack_require__(/*! on-exit-leak-free */ \"(rsc)/./node_modules/on-exit-leak-free/index.js\");\nconst { lsCacheSym, chindingsSym, writeSym, serializersSym, formatOptsSym, endSym, stringifiersSym, stringifySym, stringifySafeSym, wildcardFirstSym, nestedKeySym, formattersSym, messageKeySym, errorKeySym, nestedKeyStrSym, msgPrefixSym } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/pino/lib/symbols.js\");\nconst { isMainThread } = __webpack_require__(/*! worker_threads */ \"worker_threads\");\nconst transport = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/pino/lib/transport.js\");\nfunction noop() {}\nfunction genLog(level, hook) {\n    if (!hook) return LOG;\n    return function hookWrappedLog(...args) {\n        hook.call(this, args, LOG, level);\n    };\n    function LOG(o, ...n) {\n        if (typeof o === \"object\") {\n            let msg = o;\n            if (o !== null) {\n                if (o.method && o.headers && o.socket) {\n                    o = mapHttpRequest(o);\n                } else if (typeof o.setHeader === \"function\") {\n                    o = mapHttpResponse(o);\n                }\n            }\n            let formatParams;\n            if (msg === null && n.length === 0) {\n                formatParams = [\n                    null\n                ];\n            } else {\n                msg = n.shift();\n                formatParams = n;\n            }\n            // We do not use a coercive check for `msg` as it is\n            // measurably slower than the explicit checks.\n            if (typeof this[msgPrefixSym] === \"string\" && msg !== undefined && msg !== null) {\n                msg = this[msgPrefixSym] + msg;\n            }\n            this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);\n        } else {\n            let msg = o === undefined ? n.shift() : o;\n            // We do not use a coercive check for `msg` as it is\n            // measurably slower than the explicit checks.\n            if (typeof this[msgPrefixSym] === \"string\" && msg !== undefined && msg !== null) {\n                msg = this[msgPrefixSym] + msg;\n            }\n            this[writeSym](null, format(msg, n, this[formatOptsSym]), level);\n        }\n    }\n}\n// magically escape strings for json\n// relying on their charCodeAt\n// everything below 32 needs JSON.stringify()\n// 34 and 92 happens all the time, so we\n// have a fast case for them\nfunction asString(str) {\n    let result = \"\";\n    let last = 0;\n    let found = false;\n    let point = 255;\n    const l = str.length;\n    if (l > 100) {\n        return JSON.stringify(str);\n    }\n    for(var i = 0; i < l && point >= 32; i++){\n        point = str.charCodeAt(i);\n        if (point === 34 || point === 92) {\n            result += str.slice(last, i) + \"\\\\\";\n            last = i;\n            found = true;\n        }\n    }\n    if (!found) {\n        result = str;\n    } else {\n        result += str.slice(last);\n    }\n    return point < 32 ? JSON.stringify(str) : '\"' + result + '\"';\n}\nfunction asJson(obj, msg, num, time) {\n    const stringify = this[stringifySym];\n    const stringifySafe = this[stringifySafeSym];\n    const stringifiers = this[stringifiersSym];\n    const end = this[endSym];\n    const chindings = this[chindingsSym];\n    const serializers = this[serializersSym];\n    const formatters = this[formattersSym];\n    const messageKey = this[messageKeySym];\n    const errorKey = this[errorKeySym];\n    let data = this[lsCacheSym][num] + time;\n    // we need the child bindings added to the output first so instance logged\n    // objects can take precedence when JSON.parse-ing the resulting log line\n    data = data + chindings;\n    let value;\n    if (formatters.log) {\n        obj = formatters.log(obj);\n    }\n    const wildcardStringifier = stringifiers[wildcardFirstSym];\n    let propStr = \"\";\n    for(const key in obj){\n        value = obj[key];\n        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {\n            if (serializers[key]) {\n                value = serializers[key](value);\n            } else if (key === errorKey && serializers.err) {\n                value = serializers.err(value);\n            }\n            const stringifier = stringifiers[key] || wildcardStringifier;\n            switch(typeof value){\n                case \"undefined\":\n                case \"function\":\n                    continue;\n                case \"number\":\n                    /* eslint no-fallthrough: \"off\" */ if (Number.isFinite(value) === false) {\n                        value = null;\n                    }\n                // this case explicitly falls through to the next one\n                case \"boolean\":\n                    if (stringifier) value = stringifier(value);\n                    break;\n                case \"string\":\n                    value = (stringifier || asString)(value);\n                    break;\n                default:\n                    value = (stringifier || stringify)(value, stringifySafe);\n            }\n            if (value === undefined) continue;\n            const strKey = asString(key);\n            propStr += \",\" + strKey + \":\" + value;\n        }\n    }\n    let msgStr = \"\";\n    if (msg !== undefined) {\n        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;\n        const stringifier = stringifiers[messageKey] || wildcardStringifier;\n        switch(typeof value){\n            case \"function\":\n                break;\n            case \"number\":\n                /* eslint no-fallthrough: \"off\" */ if (Number.isFinite(value) === false) {\n                    value = null;\n                }\n            // this case explicitly falls through to the next one\n            case \"boolean\":\n                if (stringifier) value = stringifier(value);\n                msgStr = ',\"' + messageKey + '\":' + value;\n                break;\n            case \"string\":\n                value = (stringifier || asString)(value);\n                msgStr = ',\"' + messageKey + '\":' + value;\n                break;\n            default:\n                value = (stringifier || stringify)(value, stringifySafe);\n                msgStr = ',\"' + messageKey + '\":' + value;\n        }\n    }\n    if (this[nestedKeySym] && propStr) {\n        // place all the obj properties under the specified key\n        // the nested key is already formatted from the constructor\n        return data + this[nestedKeyStrSym] + propStr.slice(1) + \"}\" + msgStr + end;\n    } else {\n        return data + propStr + msgStr + end;\n    }\n}\nfunction asChindings(instance, bindings) {\n    let value;\n    let data = instance[chindingsSym];\n    const stringify = instance[stringifySym];\n    const stringifySafe = instance[stringifySafeSym];\n    const stringifiers = instance[stringifiersSym];\n    const wildcardStringifier = stringifiers[wildcardFirstSym];\n    const serializers = instance[serializersSym];\n    const formatter = instance[formattersSym].bindings;\n    bindings = formatter(bindings);\n    for(const key in bindings){\n        value = bindings[key];\n        const valid = key !== \"level\" && key !== \"serializers\" && key !== \"formatters\" && key !== \"customLevels\" && bindings.hasOwnProperty(key) && value !== undefined;\n        if (valid === true) {\n            value = serializers[key] ? serializers[key](value) : value;\n            value = (stringifiers[key] || wildcardStringifier || stringify)(value, stringifySafe);\n            if (value === undefined) continue;\n            data += ',\"' + key + '\":' + value;\n        }\n    }\n    return data;\n}\nfunction hasBeenTampered(stream) {\n    return stream.write !== stream.constructor.prototype.write;\n}\nconst hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;\nfunction buildSafeSonicBoom(opts) {\n    const stream = new SonicBoom(opts);\n    stream.on(\"error\", filterBrokenPipe);\n    // If we are sync: false, we must flush on exit\n    // We must disable this if there is node code coverage due to\n    // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308.\n    if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {\n        onExit.register(stream, autoEnd);\n        stream.on(\"close\", function() {\n            onExit.unregister(stream);\n        });\n    }\n    return stream;\n    function filterBrokenPipe(err) {\n        // Impossible to replicate across all operating systems\n        /* istanbul ignore next */ if (err.code === \"EPIPE\") {\n            // If we get EPIPE, we should stop logging here\n            // however we have no control to the consumer of\n            // SonicBoom, so we just overwrite the write method\n            stream.write = noop;\n            stream.end = noop;\n            stream.flushSync = noop;\n            stream.destroy = noop;\n            return;\n        }\n        stream.removeListener(\"error\", filterBrokenPipe);\n        stream.emit(\"error\", err);\n    }\n}\nfunction autoEnd(stream, eventName) {\n    // This check is needed only on some platforms\n    /* istanbul ignore next */ if (stream.destroyed) {\n        return;\n    }\n    if (eventName === \"beforeExit\") {\n        // We still have an event loop, let's use it\n        stream.flush();\n        stream.on(\"drain\", function() {\n            stream.end();\n        });\n    } else {\n        // For some reason istanbul is not detecting this, but it's there\n        /* istanbul ignore next */ // We do not have an event loop, so flush synchronously\n        stream.flushSync();\n    }\n}\nfunction createArgsNormalizer(defaultOptions) {\n    return function normalizeArgs(instance, caller, opts = {}, stream) {\n        // support stream as a string\n        if (typeof opts === \"string\") {\n            stream = buildSafeSonicBoom({\n                dest: opts\n            });\n            opts = {};\n        } else if (typeof stream === \"string\") {\n            if (opts && opts.transport) {\n                throw Error(\"only one of option.transport or stream can be specified\");\n            }\n            stream = buildSafeSonicBoom({\n                dest: stream\n            });\n        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {\n            stream = opts;\n            opts = {};\n        } else if (opts.transport) {\n            if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {\n                throw Error(\"option.transport do not allow stream, please pass to option directly. e.g. pino(transport)\");\n            }\n            if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === \"function\") {\n                throw Error(\"option.transport.targets do not allow custom level formatters\");\n            }\n            let customLevels;\n            if (opts.customLevels) {\n                customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);\n            }\n            stream = transport({\n                caller,\n                ...opts.transport,\n                levels: customLevels\n            });\n        }\n        opts = Object.assign({}, defaultOptions, opts);\n        opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);\n        opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);\n        if (opts.prettyPrint) {\n            throw new Error(\"prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)\");\n        }\n        const { enabled, onChild } = opts;\n        if (enabled === false) opts.level = \"silent\";\n        if (!onChild) opts.onChild = noop;\n        if (!stream) {\n            if (!hasBeenTampered(process.stdout)) {\n                // If process.stdout.fd is undefined, it means that we are running\n                // in a worker thread. Let's assume we are logging to file descriptor 1.\n                stream = buildSafeSonicBoom({\n                    fd: process.stdout.fd || 1\n                });\n            } else {\n                stream = process.stdout;\n            }\n        }\n        return {\n            opts,\n            stream\n        };\n    };\n}\nfunction stringify(obj, stringifySafeFn) {\n    try {\n        return JSON.stringify(obj);\n    } catch (_) {\n        try {\n            const stringify = stringifySafeFn || this[stringifySafeSym];\n            return stringify(obj);\n        } catch (_) {\n            return '\"[unable to serialize, circular reference is too complex to analyze]\"';\n        }\n    }\n}\nfunction buildFormatters(level, bindings, log) {\n    return {\n        level,\n        bindings,\n        log\n    };\n}\n/**\n * Convert a string integer file descriptor to a proper native integer\n * file descriptor.\n *\n * @param {string} destination The file descriptor string to attempt to convert.\n *\n * @returns {Number}\n */ function normalizeDestFileDescriptor(destination) {\n    const fd = Number(destination);\n    if (typeof destination === \"string\" && Number.isFinite(fd)) {\n        return fd;\n    }\n    // destination could be undefined if we are in a worker\n    if (destination === undefined) {\n        // This is stdout in UNIX systems\n        return 1;\n    }\n    return destination;\n}\nmodule.exports = {\n    noop,\n    buildSafeSonicBoom,\n    asChindings,\n    asJson,\n    genLog,\n    createArgsNormalizer,\n    stringify,\n    buildFormatters,\n    normalizeDestFileDescriptor\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0I1RixXQUFXO1FBQzdCLGlDQUFpQztRQUNqQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPNEY7QUFDVDtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZmhIO0lBQ0F3RTtJQUNBZDtJQUNBM0I7SUFDQTlCO0lBQ0F1RjtJQUNBN0Q7SUFDQWlGO0lBQ0FDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZWN0YXItYWRtaW4tdjEvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdG9vbHMuanM/MzBkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyogZXNsaW50IG5vLXByb3RvdHlwZS1idWlsdGluczogMCAqL1xuXG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCdxdWljay1mb3JtYXQtdW5lc2NhcGVkJylcbmNvbnN0IHsgbWFwSHR0cFJlcXVlc3QsIG1hcEh0dHBSZXNwb25zZSB9ID0gcmVxdWlyZSgncGluby1zdGQtc2VyaWFsaXplcnMnKVxuY29uc3QgU29uaWNCb29tID0gcmVxdWlyZSgnc29uaWMtYm9vbScpXG5jb25zdCBvbkV4aXQgPSByZXF1aXJlKCdvbi1leGl0LWxlYWstZnJlZScpXG5jb25zdCB7XG4gIGxzQ2FjaGVTeW0sXG4gIGNoaW5kaW5nc1N5bSxcbiAgd3JpdGVTeW0sXG4gIHNlcmlhbGl6ZXJzU3ltLFxuICBmb3JtYXRPcHRzU3ltLFxuICBlbmRTeW0sXG4gIHN0cmluZ2lmaWVyc1N5bSxcbiAgc3RyaW5naWZ5U3ltLFxuICBzdHJpbmdpZnlTYWZlU3ltLFxuICB3aWxkY2FyZEZpcnN0U3ltLFxuICBuZXN0ZWRLZXlTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIG1lc3NhZ2VLZXlTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBuZXN0ZWRLZXlTdHJTeW0sXG4gIG1zZ1ByZWZpeFN5bVxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGlzTWFpblRocmVhZCB9ID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKVxuY29uc3QgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKVxuXG5mdW5jdGlvbiBub29wICgpIHtcbn1cblxuZnVuY3Rpb24gZ2VuTG9nIChsZXZlbCwgaG9vaykge1xuICBpZiAoIWhvb2spIHJldHVybiBMT0dcblxuICByZXR1cm4gZnVuY3Rpb24gaG9va1dyYXBwZWRMb2cgKC4uLmFyZ3MpIHtcbiAgICBob29rLmNhbGwodGhpcywgYXJncywgTE9HLCBsZXZlbClcbiAgfVxuXG4gIGZ1bmN0aW9uIExPRyAobywgLi4ubikge1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGxldCBtc2cgPSBvXG4gICAgICBpZiAobyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoby5tZXRob2QgJiYgby5oZWFkZXJzICYmIG8uc29ja2V0KSB7XG4gICAgICAgICAgbyA9IG1hcEh0dHBSZXF1ZXN0KG8pXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG8uc2V0SGVhZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbyA9IG1hcEh0dHBSZXNwb25zZShvKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgZm9ybWF0UGFyYW1zXG4gICAgICBpZiAobXNnID09PSBudWxsICYmIG4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZvcm1hdFBhcmFtcyA9IFtudWxsXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXNnID0gbi5zaGlmdCgpXG4gICAgICAgIGZvcm1hdFBhcmFtcyA9IG5cbiAgICAgIH1cbiAgICAgIC8vIFdlIGRvIG5vdCB1c2UgYSBjb2VyY2l2ZSBjaGVjayBmb3IgYG1zZ2AgYXMgaXQgaXNcbiAgICAgIC8vIG1lYXN1cmFibHkgc2xvd2VyIHRoYW4gdGhlIGV4cGxpY2l0IGNoZWNrcy5cbiAgICAgIGlmICh0eXBlb2YgdGhpc1ttc2dQcmVmaXhTeW1dID09PSAnc3RyaW5nJyAmJiBtc2cgIT09IHVuZGVmaW5lZCAmJiBtc2cgIT09IG51bGwpIHtcbiAgICAgICAgbXNnID0gdGhpc1ttc2dQcmVmaXhTeW1dICsgbXNnXG4gICAgICB9XG4gICAgICB0aGlzW3dyaXRlU3ltXShvLCBmb3JtYXQobXNnLCBmb3JtYXRQYXJhbXMsIHRoaXNbZm9ybWF0T3B0c1N5bV0pLCBsZXZlbClcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1zZyA9IG8gPT09IHVuZGVmaW5lZCA/IG4uc2hpZnQoKSA6IG9cblxuICAgICAgLy8gV2UgZG8gbm90IHVzZSBhIGNvZXJjaXZlIGNoZWNrIGZvciBgbXNnYCBhcyBpdCBpc1xuICAgICAgLy8gbWVhc3VyYWJseSBzbG93ZXIgdGhhbiB0aGUgZXhwbGljaXQgY2hlY2tzLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzW21zZ1ByZWZpeFN5bV0gPT09ICdzdHJpbmcnICYmIG1zZyAhPT0gdW5kZWZpbmVkICYmIG1zZyAhPT0gbnVsbCkge1xuICAgICAgICBtc2cgPSB0aGlzW21zZ1ByZWZpeFN5bV0gKyBtc2dcbiAgICAgIH1cbiAgICAgIHRoaXNbd3JpdGVTeW1dKG51bGwsIGZvcm1hdChtc2csIG4sIHRoaXNbZm9ybWF0T3B0c1N5bV0pLCBsZXZlbClcbiAgICB9XG4gIH1cbn1cblxuLy8gbWFnaWNhbGx5IGVzY2FwZSBzdHJpbmdzIGZvciBqc29uXG4vLyByZWx5aW5nIG9uIHRoZWlyIGNoYXJDb2RlQXRcbi8vIGV2ZXJ5dGhpbmcgYmVsb3cgMzIgbmVlZHMgSlNPTi5zdHJpbmdpZnkoKVxuLy8gMzQgYW5kIDkyIGhhcHBlbnMgYWxsIHRoZSB0aW1lLCBzbyB3ZVxuLy8gaGF2ZSBhIGZhc3QgY2FzZSBmb3IgdGhlbVxuZnVuY3Rpb24gYXNTdHJpbmcgKHN0cikge1xuICBsZXQgcmVzdWx0ID0gJydcbiAgbGV0IGxhc3QgPSAwXG4gIGxldCBmb3VuZCA9IGZhbHNlXG4gIGxldCBwb2ludCA9IDI1NVxuICBjb25zdCBsID0gc3RyLmxlbmd0aFxuICBpZiAobCA+IDEwMCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsICYmIHBvaW50ID49IDMyOyBpKyspIHtcbiAgICBwb2ludCA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKHBvaW50ID09PSAzNCB8fCBwb2ludCA9PT0gOTIpIHtcbiAgICAgIHJlc3VsdCArPSBzdHIuc2xpY2UobGFzdCwgaSkgKyAnXFxcXCdcbiAgICAgIGxhc3QgPSBpXG4gICAgICBmb3VuZCA9IHRydWVcbiAgICB9XG4gIH1cbiAgaWYgKCFmb3VuZCkge1xuICAgIHJlc3VsdCA9IHN0clxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBzdHIuc2xpY2UobGFzdClcbiAgfVxuICByZXR1cm4gcG9pbnQgPCAzMiA/IEpTT04uc3RyaW5naWZ5KHN0cikgOiAnXCInICsgcmVzdWx0ICsgJ1wiJ1xufVxuXG5mdW5jdGlvbiBhc0pzb24gKG9iaiwgbXNnLCBudW0sIHRpbWUpIHtcbiAgY29uc3Qgc3RyaW5naWZ5ID0gdGhpc1tzdHJpbmdpZnlTeW1dXG4gIGNvbnN0IHN0cmluZ2lmeVNhZmUgPSB0aGlzW3N0cmluZ2lmeVNhZmVTeW1dXG4gIGNvbnN0IHN0cmluZ2lmaWVycyA9IHRoaXNbc3RyaW5naWZpZXJzU3ltXVxuICBjb25zdCBlbmQgPSB0aGlzW2VuZFN5bV1cbiAgY29uc3QgY2hpbmRpbmdzID0gdGhpc1tjaGluZGluZ3NTeW1dXG4gIGNvbnN0IHNlcmlhbGl6ZXJzID0gdGhpc1tzZXJpYWxpemVyc1N5bV1cbiAgY29uc3QgZm9ybWF0dGVycyA9IHRoaXNbZm9ybWF0dGVyc1N5bV1cbiAgY29uc3QgbWVzc2FnZUtleSA9IHRoaXNbbWVzc2FnZUtleVN5bV1cbiAgY29uc3QgZXJyb3JLZXkgPSB0aGlzW2Vycm9yS2V5U3ltXVxuICBsZXQgZGF0YSA9IHRoaXNbbHNDYWNoZVN5bV1bbnVtXSArIHRpbWVcblxuICAvLyB3ZSBuZWVkIHRoZSBjaGlsZCBiaW5kaW5ncyBhZGRlZCB0byB0aGUgb3V0cHV0IGZpcnN0IHNvIGluc3RhbmNlIGxvZ2dlZFxuICAvLyBvYmplY3RzIGNhbiB0YWtlIHByZWNlZGVuY2Ugd2hlbiBKU09OLnBhcnNlLWluZyB0aGUgcmVzdWx0aW5nIGxvZyBsaW5lXG4gIGRhdGEgPSBkYXRhICsgY2hpbmRpbmdzXG5cbiAgbGV0IHZhbHVlXG4gIGlmIChmb3JtYXR0ZXJzLmxvZykge1xuICAgIG9iaiA9IGZvcm1hdHRlcnMubG9nKG9iailcbiAgfVxuICBjb25zdCB3aWxkY2FyZFN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW3dpbGRjYXJkRmlyc3RTeW1dXG4gIGxldCBwcm9wU3RyID0gJydcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgdmFsdWUgPSBvYmpba2V5XVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChzZXJpYWxpemVyc1trZXldKSB7XG4gICAgICAgIHZhbHVlID0gc2VyaWFsaXplcnNba2V5XSh2YWx1ZSlcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBlcnJvcktleSAmJiBzZXJpYWxpemVycy5lcnIpIHtcbiAgICAgICAgdmFsdWUgPSBzZXJpYWxpemVycy5lcnIodmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW2tleV0gfHwgd2lsZGNhcmRTdHJpbmdpZmllclxuXG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFwib2ZmXCIgKi9cbiAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBjYXNlIGV4cGxpY2l0bHkgZmFsbHMgdGhyb3VnaCB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgaWYgKHN0cmluZ2lmaWVyKSB2YWx1ZSA9IHN0cmluZ2lmaWVyKHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgdmFsdWUgPSAoc3RyaW5naWZpZXIgfHwgYXNTdHJpbmcpKHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFsdWUgPSAoc3RyaW5naWZpZXIgfHwgc3RyaW5naWZ5KSh2YWx1ZSwgc3RyaW5naWZ5U2FmZSlcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgY29uc3Qgc3RyS2V5ID0gYXNTdHJpbmcoa2V5KVxuICAgICAgcHJvcFN0ciArPSAnLCcgKyBzdHJLZXkgKyAnOicgKyB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIGxldCBtc2dTdHIgPSAnJ1xuICBpZiAobXNnICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IHNlcmlhbGl6ZXJzW21lc3NhZ2VLZXldID8gc2VyaWFsaXplcnNbbWVzc2FnZUtleV0obXNnKSA6IG1zZ1xuICAgIGNvbnN0IHN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW21lc3NhZ2VLZXldIHx8IHdpbGRjYXJkU3RyaW5naWZpZXJcblxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFwib2ZmXCIgKi9cbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFsdWUgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIC8vIHRoaXMgY2FzZSBleHBsaWNpdGx5IGZhbGxzIHRocm91Z2ggdG8gdGhlIG5leHQgb25lXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgaWYgKHN0cmluZ2lmaWVyKSB2YWx1ZSA9IHN0cmluZ2lmaWVyKHZhbHVlKVxuICAgICAgICBtc2dTdHIgPSAnLFwiJyArIG1lc3NhZ2VLZXkgKyAnXCI6JyArIHZhbHVlXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB2YWx1ZSA9IChzdHJpbmdpZmllciB8fCBhc1N0cmluZykodmFsdWUpXG4gICAgICAgIG1zZ1N0ciA9ICcsXCInICsgbWVzc2FnZUtleSArICdcIjonICsgdmFsdWVcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhbHVlID0gKHN0cmluZ2lmaWVyIHx8IHN0cmluZ2lmeSkodmFsdWUsIHN0cmluZ2lmeVNhZmUpXG4gICAgICAgIG1zZ1N0ciA9ICcsXCInICsgbWVzc2FnZUtleSArICdcIjonICsgdmFsdWVcbiAgICB9XG4gIH1cblxuICBpZiAodGhpc1tuZXN0ZWRLZXlTeW1dICYmIHByb3BTdHIpIHtcbiAgICAvLyBwbGFjZSBhbGwgdGhlIG9iaiBwcm9wZXJ0aWVzIHVuZGVyIHRoZSBzcGVjaWZpZWQga2V5XG4gICAgLy8gdGhlIG5lc3RlZCBrZXkgaXMgYWxyZWFkeSBmb3JtYXR0ZWQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICByZXR1cm4gZGF0YSArIHRoaXNbbmVzdGVkS2V5U3RyU3ltXSArIHByb3BTdHIuc2xpY2UoMSkgKyAnfScgKyBtc2dTdHIgKyBlbmRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YSArIHByb3BTdHIgKyBtc2dTdHIgKyBlbmRcbiAgfVxufVxuXG5mdW5jdGlvbiBhc0NoaW5kaW5ncyAoaW5zdGFuY2UsIGJpbmRpbmdzKSB7XG4gIGxldCB2YWx1ZVxuICBsZXQgZGF0YSA9IGluc3RhbmNlW2NoaW5kaW5nc1N5bV1cbiAgY29uc3Qgc3RyaW5naWZ5ID0gaW5zdGFuY2Vbc3RyaW5naWZ5U3ltXVxuICBjb25zdCBzdHJpbmdpZnlTYWZlID0gaW5zdGFuY2Vbc3RyaW5naWZ5U2FmZVN5bV1cbiAgY29uc3Qgc3RyaW5naWZpZXJzID0gaW5zdGFuY2Vbc3RyaW5naWZpZXJzU3ltXVxuICBjb25zdCB3aWxkY2FyZFN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW3dpbGRjYXJkRmlyc3RTeW1dXG4gIGNvbnN0IHNlcmlhbGl6ZXJzID0gaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dXG4gIGNvbnN0IGZvcm1hdHRlciA9IGluc3RhbmNlW2Zvcm1hdHRlcnNTeW1dLmJpbmRpbmdzXG4gIGJpbmRpbmdzID0gZm9ybWF0dGVyKGJpbmRpbmdzKVxuXG4gIGZvciAoY29uc3Qga2V5IGluIGJpbmRpbmdzKSB7XG4gICAgdmFsdWUgPSBiaW5kaW5nc1trZXldXG4gICAgY29uc3QgdmFsaWQgPSBrZXkgIT09ICdsZXZlbCcgJiZcbiAgICAgIGtleSAhPT0gJ3NlcmlhbGl6ZXJzJyAmJlxuICAgICAga2V5ICE9PSAnZm9ybWF0dGVycycgJiZcbiAgICAgIGtleSAhPT0gJ2N1c3RvbUxldmVscycgJiZcbiAgICAgIGJpbmRpbmdzLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICBpZiAodmFsaWQgPT09IHRydWUpIHtcbiAgICAgIHZhbHVlID0gc2VyaWFsaXplcnNba2V5XSA/IHNlcmlhbGl6ZXJzW2tleV0odmFsdWUpIDogdmFsdWVcbiAgICAgIHZhbHVlID0gKHN0cmluZ2lmaWVyc1trZXldIHx8IHdpbGRjYXJkU3RyaW5naWZpZXIgfHwgc3RyaW5naWZ5KSh2YWx1ZSwgc3RyaW5naWZ5U2FmZSlcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgZGF0YSArPSAnLFwiJyArIGtleSArICdcIjonICsgdmFsdWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gaGFzQmVlblRhbXBlcmVkIChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZSAhPT0gc3RyZWFtLmNvbnN0cnVjdG9yLnByb3RvdHlwZS53cml0ZVxufVxuXG5jb25zdCBoYXNOb2RlQ29kZUNvdmVyYWdlID0gcHJvY2Vzcy5lbnYuTk9ERV9WOF9DT1ZFUkFHRSB8fCBwcm9jZXNzLmVudi5WOF9DT1ZFUkFHRVxuXG5mdW5jdGlvbiBidWlsZFNhZmVTb25pY0Jvb20gKG9wdHMpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFNvbmljQm9vbShvcHRzKVxuICBzdHJlYW0ub24oJ2Vycm9yJywgZmlsdGVyQnJva2VuUGlwZSlcbiAgLy8gSWYgd2UgYXJlIHN5bmM6IGZhbHNlLCB3ZSBtdXN0IGZsdXNoIG9uIGV4aXRcbiAgLy8gV2UgbXVzdCBkaXNhYmxlIHRoaXMgaWYgdGhlcmUgaXMgbm9kZSBjb2RlIGNvdmVyYWdlIGR1ZSB0b1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MzQ0I2lzc3VlY29tbWVudC0xNzQxNzc2MzA4LlxuICBpZiAoIWhhc05vZGVDb2RlQ292ZXJhZ2UgJiYgIW9wdHMuc3luYyAmJiBpc01haW5UaHJlYWQpIHtcbiAgICBvbkV4aXQucmVnaXN0ZXIoc3RyZWFtLCBhdXRvRW5kKVxuXG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uRXhpdC51bnJlZ2lzdGVyKHN0cmVhbSlcbiAgICB9KVxuICB9XG4gIHJldHVybiBzdHJlYW1cblxuICBmdW5jdGlvbiBmaWx0ZXJCcm9rZW5QaXBlIChlcnIpIHtcbiAgICAvLyBJbXBvc3NpYmxlIHRvIHJlcGxpY2F0ZSBhY3Jvc3MgYWxsIG9wZXJhdGluZyBzeXN0ZW1zXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFUElQRScpIHtcbiAgICAgIC8vIElmIHdlIGdldCBFUElQRSwgd2Ugc2hvdWxkIHN0b3AgbG9nZ2luZyBoZXJlXG4gICAgICAvLyBob3dldmVyIHdlIGhhdmUgbm8gY29udHJvbCB0byB0aGUgY29uc3VtZXIgb2ZcbiAgICAgIC8vIFNvbmljQm9vbSwgc28gd2UganVzdCBvdmVyd3JpdGUgdGhlIHdyaXRlIG1ldGhvZFxuICAgICAgc3RyZWFtLndyaXRlID0gbm9vcFxuICAgICAgc3RyZWFtLmVuZCA9IG5vb3BcbiAgICAgIHN0cmVhbS5mbHVzaFN5bmMgPSBub29wXG4gICAgICBzdHJlYW0uZGVzdHJveSA9IG5vb3BcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZmlsdGVyQnJva2VuUGlwZSlcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXV0b0VuZCAoc3RyZWFtLCBldmVudE5hbWUpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgb25seSBvbiBzb21lIHBsYXRmb3Jtc1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2JlZm9yZUV4aXQnKSB7XG4gICAgLy8gV2Ugc3RpbGwgaGF2ZSBhbiBldmVudCBsb29wLCBsZXQncyB1c2UgaXRcbiAgICBzdHJlYW0uZmx1c2goKVxuICAgIHN0cmVhbS5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHJlYW0uZW5kKClcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIEZvciBzb21lIHJlYXNvbiBpc3RhbmJ1bCBpcyBub3QgZGV0ZWN0aW5nIHRoaXMsIGJ1dCBpdCdzIHRoZXJlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAvLyBXZSBkbyBub3QgaGF2ZSBhbiBldmVudCBsb29wLCBzbyBmbHVzaCBzeW5jaHJvbm91c2x5XG4gICAgc3RyZWFtLmZsdXNoU3luYygpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJnc05vcm1hbGl6ZXIgKGRlZmF1bHRPcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub3JtYWxpemVBcmdzIChpbnN0YW5jZSwgY2FsbGVyLCBvcHRzID0ge30sIHN0cmVhbSkge1xuICAgIC8vIHN1cHBvcnQgc3RyZWFtIGFzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgc3RyZWFtID0gYnVpbGRTYWZlU29uaWNCb29tKHsgZGVzdDogb3B0cyB9KVxuICAgICAgb3B0cyA9IHt9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyZWFtID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy50cmFuc3BvcnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29ubHkgb25lIG9mIG9wdGlvbi50cmFuc3BvcnQgb3Igc3RyZWFtIGNhbiBiZSBzcGVjaWZpZWQnKVxuICAgICAgfVxuICAgICAgc3RyZWFtID0gYnVpbGRTYWZlU29uaWNCb29tKHsgZGVzdDogc3RyZWFtIH0pXG4gICAgfSBlbHNlIGlmIChvcHRzIGluc3RhbmNlb2YgU29uaWNCb29tIHx8IG9wdHMud3JpdGFibGUgfHwgb3B0cy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgc3RyZWFtID0gb3B0c1xuICAgICAgb3B0cyA9IHt9XG4gICAgfSBlbHNlIGlmIChvcHRzLnRyYW5zcG9ydCkge1xuICAgICAgaWYgKG9wdHMudHJhbnNwb3J0IGluc3RhbmNlb2YgU29uaWNCb29tIHx8IG9wdHMudHJhbnNwb3J0LndyaXRhYmxlIHx8IG9wdHMudHJhbnNwb3J0Ll93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdvcHRpb24udHJhbnNwb3J0IGRvIG5vdCBhbGxvdyBzdHJlYW0sIHBsZWFzZSBwYXNzIHRvIG9wdGlvbiBkaXJlY3RseS4gZS5nLiBwaW5vKHRyYW5zcG9ydCknKVxuICAgICAgfVxuICAgICAgaWYgKG9wdHMudHJhbnNwb3J0LnRhcmdldHMgJiYgb3B0cy50cmFuc3BvcnQudGFyZ2V0cy5sZW5ndGggJiYgb3B0cy5mb3JtYXR0ZXJzICYmIHR5cGVvZiBvcHRzLmZvcm1hdHRlcnMubGV2ZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29wdGlvbi50cmFuc3BvcnQudGFyZ2V0cyBkbyBub3QgYWxsb3cgY3VzdG9tIGxldmVsIGZvcm1hdHRlcnMnKVxuICAgICAgfVxuXG4gICAgICBsZXQgY3VzdG9tTGV2ZWxzXG4gICAgICBpZiAob3B0cy5jdXN0b21MZXZlbHMpIHtcbiAgICAgICAgY3VzdG9tTGV2ZWxzID0gb3B0cy51c2VPbmx5Q3VzdG9tTGV2ZWxzID8gb3B0cy5jdXN0b21MZXZlbHMgOiBPYmplY3QuYXNzaWduKHt9LCBvcHRzLmxldmVscywgb3B0cy5jdXN0b21MZXZlbHMpXG4gICAgICB9XG4gICAgICBzdHJlYW0gPSB0cmFuc3BvcnQoeyBjYWxsZXIsIC4uLm9wdHMudHJhbnNwb3J0LCBsZXZlbHM6IGN1c3RvbUxldmVscyB9KVxuICAgIH1cbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdHMpXG4gICAgb3B0cy5zZXJpYWxpemVycyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLnNlcmlhbGl6ZXJzLCBvcHRzLnNlcmlhbGl6ZXJzKVxuICAgIG9wdHMuZm9ybWF0dGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLmZvcm1hdHRlcnMsIG9wdHMuZm9ybWF0dGVycylcblxuICAgIGlmIChvcHRzLnByZXR0eVByaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXR0eVByaW50IG9wdGlvbiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLCBzZWUgdGhlIHBpbm8tcHJldHR5IHBhY2thZ2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9waW5vanMvcGluby1wcmV0dHkpJylcbiAgICB9XG5cbiAgICBjb25zdCB7IGVuYWJsZWQsIG9uQ2hpbGQgfSA9IG9wdHNcbiAgICBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIG9wdHMubGV2ZWwgPSAnc2lsZW50J1xuICAgIGlmICghb25DaGlsZCkgb3B0cy5vbkNoaWxkID0gbm9vcFxuICAgIGlmICghc3RyZWFtKSB7XG4gICAgICBpZiAoIWhhc0JlZW5UYW1wZXJlZChwcm9jZXNzLnN0ZG91dCkpIHtcbiAgICAgICAgLy8gSWYgcHJvY2Vzcy5zdGRvdXQuZmQgaXMgdW5kZWZpbmVkLCBpdCBtZWFucyB0aGF0IHdlIGFyZSBydW5uaW5nXG4gICAgICAgIC8vIGluIGEgd29ya2VyIHRocmVhZC4gTGV0J3MgYXNzdW1lIHdlIGFyZSBsb2dnaW5nIHRvIGZpbGUgZGVzY3JpcHRvciAxLlxuICAgICAgICBzdHJlYW0gPSBidWlsZFNhZmVTb25pY0Jvb20oeyBmZDogcHJvY2Vzcy5zdGRvdXQuZmQgfHwgMSB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtID0gcHJvY2Vzcy5zdGRvdXRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgb3B0cywgc3RyZWFtIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgc3RyaW5naWZ5U2FmZUZuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iailcbiAgfSBjYXRjaCAoXykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJpbmdpZnkgPSBzdHJpbmdpZnlTYWZlRm4gfHwgdGhpc1tzdHJpbmdpZnlTYWZlU3ltXVxuICAgICAgcmV0dXJuIHN0cmluZ2lmeShvYmopXG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuICdcIlt1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV1cIidcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRGb3JtYXR0ZXJzIChsZXZlbCwgYmluZGluZ3MsIGxvZykge1xuICByZXR1cm4ge1xuICAgIGxldmVsLFxuICAgIGJpbmRpbmdzLFxuICAgIGxvZ1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBpbnRlZ2VyIGZpbGUgZGVzY3JpcHRvciB0byBhIHByb3BlciBuYXRpdmUgaW50ZWdlclxuICogZmlsZSBkZXNjcmlwdG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbiBUaGUgZmlsZSBkZXNjcmlwdG9yIHN0cmluZyB0byBhdHRlbXB0IHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yIChkZXN0aW5hdGlvbikge1xuICBjb25zdCBmZCA9IE51bWJlcihkZXN0aW5hdGlvbilcbiAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gJ3N0cmluZycgJiYgTnVtYmVyLmlzRmluaXRlKGZkKSkge1xuICAgIHJldHVybiBmZFxuICB9XG4gIC8vIGRlc3RpbmF0aW9uIGNvdWxkIGJlIHVuZGVmaW5lZCBpZiB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgaWYgKGRlc3RpbmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUaGlzIGlzIHN0ZG91dCBpbiBVTklYIHN5c3RlbXNcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbm9vcCxcbiAgYnVpbGRTYWZlU29uaWNCb29tLFxuICBhc0NoaW5kaW5ncyxcbiAgYXNKc29uLFxuICBnZW5Mb2csXG4gIGNyZWF0ZUFyZ3NOb3JtYWxpemVyLFxuICBzdHJpbmdpZnksXG4gIGJ1aWxkRm9ybWF0dGVycyxcbiAgbm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yXG59XG4iXSwibmFtZXMiOlsiZm9ybWF0IiwicmVxdWlyZSIsIm1hcEh0dHBSZXF1ZXN0IiwibWFwSHR0cFJlc3BvbnNlIiwiU29uaWNCb29tIiwib25FeGl0IiwibHNDYWNoZVN5bSIsImNoaW5kaW5nc1N5bSIsIndyaXRlU3ltIiwic2VyaWFsaXplcnNTeW0iLCJmb3JtYXRPcHRzU3ltIiwiZW5kU3ltIiwic3RyaW5naWZpZXJzU3ltIiwic3RyaW5naWZ5U3ltIiwic3RyaW5naWZ5U2FmZVN5bSIsIndpbGRjYXJkRmlyc3RTeW0iLCJuZXN0ZWRLZXlTeW0iLCJmb3JtYXR0ZXJzU3ltIiwibWVzc2FnZUtleVN5bSIsImVycm9yS2V5U3ltIiwibmVzdGVkS2V5U3RyU3ltIiwibXNnUHJlZml4U3ltIiwiaXNNYWluVGhyZWFkIiwidHJhbnNwb3J0Iiwibm9vcCIsImdlbkxvZyIsImxldmVsIiwiaG9vayIsIkxPRyIsImhvb2tXcmFwcGVkTG9nIiwiYXJncyIsImNhbGwiLCJvIiwibiIsIm1zZyIsIm1ldGhvZCIsImhlYWRlcnMiLCJzb2NrZXQiLCJzZXRIZWFkZXIiLCJmb3JtYXRQYXJhbXMiLCJsZW5ndGgiLCJzaGlmdCIsInVuZGVmaW5lZCIsImFzU3RyaW5nIiwic3RyIiwicmVzdWx0IiwibGFzdCIsImZvdW5kIiwicG9pbnQiLCJsIiwiSlNPTiIsInN0cmluZ2lmeSIsImkiLCJjaGFyQ29kZUF0Iiwic2xpY2UiLCJhc0pzb24iLCJvYmoiLCJudW0iLCJ0aW1lIiwic3RyaW5naWZ5U2FmZSIsInN0cmluZ2lmaWVycyIsImVuZCIsImNoaW5kaW5ncyIsInNlcmlhbGl6ZXJzIiwiZm9ybWF0dGVycyIsIm1lc3NhZ2VLZXkiLCJlcnJvcktleSIsImRhdGEiLCJ2YWx1ZSIsImxvZyIsIndpbGRjYXJkU3RyaW5naWZpZXIiLCJwcm9wU3RyIiwia2V5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJlcnIiLCJzdHJpbmdpZmllciIsIk51bWJlciIsImlzRmluaXRlIiwic3RyS2V5IiwibXNnU3RyIiwiYXNDaGluZGluZ3MiLCJpbnN0YW5jZSIsImJpbmRpbmdzIiwiZm9ybWF0dGVyIiwidmFsaWQiLCJoYXNCZWVuVGFtcGVyZWQiLCJzdHJlYW0iLCJ3cml0ZSIsImNvbnN0cnVjdG9yIiwiaGFzTm9kZUNvZGVDb3ZlcmFnZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX1Y4X0NPVkVSQUdFIiwiVjhfQ09WRVJBR0UiLCJidWlsZFNhZmVTb25pY0Jvb20iLCJvcHRzIiwib24iLCJmaWx0ZXJCcm9rZW5QaXBlIiwic3luYyIsInJlZ2lzdGVyIiwiYXV0b0VuZCIsInVucmVnaXN0ZXIiLCJjb2RlIiwiZmx1c2hTeW5jIiwiZGVzdHJveSIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCIsImV2ZW50TmFtZSIsImRlc3Ryb3llZCIsImZsdXNoIiwiY3JlYXRlQXJnc05vcm1hbGl6ZXIiLCJkZWZhdWx0T3B0aW9ucyIsIm5vcm1hbGl6ZUFyZ3MiLCJjYWxsZXIiLCJkZXN0IiwiRXJyb3IiLCJ3cml0YWJsZSIsIl93cml0YWJsZVN0YXRlIiwidGFyZ2V0cyIsImN1c3RvbUxldmVscyIsInVzZU9ubHlDdXN0b21MZXZlbHMiLCJhc3NpZ24iLCJsZXZlbHMiLCJwcmV0dHlQcmludCIsImVuYWJsZWQiLCJvbkNoaWxkIiwic3Rkb3V0IiwiZmQiLCJzdHJpbmdpZnlTYWZlRm4iLCJfIiwiYnVpbGRGb3JtYXR0ZXJzIiwibm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yIiwiZGVzdGluYXRpb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/tools.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/transport.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/transport.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { createRequire } = __webpack_require__(/*! module */ \"module\");\nconst getCallers = __webpack_require__(/*! ./caller */ \"(rsc)/./node_modules/pino/lib/caller.js\");\nconst { join, isAbsolute, sep } = __webpack_require__(/*! path */ \"path\");\nconst sleep = __webpack_require__(/*! atomic-sleep */ \"(rsc)/./node_modules/atomic-sleep/index.js\");\nconst onExit = __webpack_require__(/*! on-exit-leak-free */ \"(rsc)/./node_modules/on-exit-leak-free/index.js\");\nconst ThreadStream = __webpack_require__(/*! thread-stream */ \"(rsc)/./node_modules/thread-stream/index.js\");\nfunction setupOnExit(stream) {\n    // This is leak free, it does not leave event handlers\n    onExit.register(stream, autoEnd);\n    onExit.registerBeforeExit(stream, flush);\n    stream.on(\"close\", function() {\n        onExit.unregister(stream);\n    });\n}\nfunction buildStream(filename, workerData, workerOpts) {\n    const stream = new ThreadStream({\n        filename,\n        workerData,\n        workerOpts\n    });\n    stream.on(\"ready\", onReady);\n    stream.on(\"close\", function() {\n        process.removeListener(\"exit\", onExit);\n    });\n    process.on(\"exit\", onExit);\n    function onReady() {\n        process.removeListener(\"exit\", onExit);\n        stream.unref();\n        if (workerOpts.autoEnd !== false) {\n            setupOnExit(stream);\n        }\n    }\n    function onExit() {\n        /* istanbul ignore next */ if (stream.closed) {\n            return;\n        }\n        stream.flushSync();\n        // Apparently there is a very sporadic race condition\n        // that in certain OS would prevent the messages to be flushed\n        // because the thread might not have been created still.\n        // Unfortunately we need to sleep(100) in this case.\n        sleep(100);\n        stream.end();\n    }\n    return stream;\n}\nfunction autoEnd(stream) {\n    stream.ref();\n    stream.flushSync();\n    stream.end();\n    stream.once(\"close\", function() {\n        stream.unref();\n    });\n}\nfunction flush(stream) {\n    stream.flushSync();\n}\nfunction transport(fullOptions) {\n    const { pipeline, targets, levels, dedupe, options = {}, worker = {}, caller = getCallers() } = fullOptions;\n    // Backwards compatibility\n    const callers = typeof caller === \"string\" ? [\n        caller\n    ] : caller;\n    // This will be eventually modified by bundlers\n    const bundlerOverrides = \"__bundlerPathsOverrides\" in globalThis ? globalThis.__bundlerPathsOverrides : {};\n    let target = fullOptions.target;\n    if (target && targets) {\n        throw new Error(\"only one of target or targets can be specified\");\n    }\n    if (targets) {\n        target = bundlerOverrides[\"pino-worker\"] || join(__dirname, \"worker.js\");\n        options.targets = targets.map((dest)=>{\n            return {\n                ...dest,\n                target: fixTarget(dest.target)\n            };\n        });\n    } else if (pipeline) {\n        target = bundlerOverrides[\"pino-pipeline-worker\"] || join(__dirname, \"worker-pipeline.js\");\n        options.targets = pipeline.map((dest)=>{\n            return {\n                ...dest,\n                target: fixTarget(dest.target)\n            };\n        });\n    }\n    if (levels) {\n        options.levels = levels;\n    }\n    if (dedupe) {\n        options.dedupe = dedupe;\n    }\n    options.pinoWillSendConfig = true;\n    return buildStream(fixTarget(target), options, worker);\n    function fixTarget(origin) {\n        origin = bundlerOverrides[origin] || origin;\n        if (isAbsolute(origin) || origin.indexOf(\"file://\") === 0) {\n            return origin;\n        }\n        if (origin === \"pino/file\") {\n            return join(__dirname, \"..\", \"file.js\");\n        }\n        let fixTarget;\n        for (const filePath of callers){\n            try {\n                const context = filePath === \"node:repl\" ? process.cwd() + sep : filePath;\n                fixTarget = createRequire(context).resolve(origin);\n                break;\n            } catch (err) {\n                continue;\n            }\n        }\n        if (!fixTarget) {\n            throw new Error(`unable to determine transport target for \"${origin}\"`);\n        }\n        return fixTarget;\n    }\n}\nmodule.exports = transport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxhQUFhLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDbEMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFRSxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsR0FBRyxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQzFDLE1BQU1LLFFBQVFMLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1NLFNBQVNOLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1PLGVBQWVQLG1CQUFPQSxDQUFDO0FBRTdCLFNBQVNRLFlBQWFDLE1BQU07SUFDMUIsc0RBQXNEO0lBQ3RESCxPQUFPSSxRQUFRLENBQUNELFFBQVFFO0lBQ3hCTCxPQUFPTSxrQkFBa0IsQ0FBQ0gsUUFBUUk7SUFFbENKLE9BQU9LLEVBQUUsQ0FBQyxTQUFTO1FBQ2pCUixPQUFPUyxVQUFVLENBQUNOO0lBQ3BCO0FBQ0Y7QUFFQSxTQUFTTyxZQUFhQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsVUFBVTtJQUNwRCxNQUFNVixTQUFTLElBQUlGLGFBQWE7UUFDOUJVO1FBQ0FDO1FBQ0FDO0lBQ0Y7SUFFQVYsT0FBT0ssRUFBRSxDQUFDLFNBQVNNO0lBQ25CWCxPQUFPSyxFQUFFLENBQUMsU0FBUztRQUNqQk8sUUFBUUMsY0FBYyxDQUFDLFFBQVFoQjtJQUNqQztJQUVBZSxRQUFRUCxFQUFFLENBQUMsUUFBUVI7SUFFbkIsU0FBU2M7UUFDUEMsUUFBUUMsY0FBYyxDQUFDLFFBQVFoQjtRQUMvQkcsT0FBT2MsS0FBSztRQUVaLElBQUlKLFdBQVdSLE9BQU8sS0FBSyxPQUFPO1lBQ2hDSCxZQUFZQztRQUNkO0lBQ0Y7SUFFQSxTQUFTSDtRQUNQLHdCQUF3QixHQUN4QixJQUFJRyxPQUFPZSxNQUFNLEVBQUU7WUFDakI7UUFDRjtRQUNBZixPQUFPZ0IsU0FBUztRQUNoQixxREFBcUQ7UUFDckQsOERBQThEO1FBQzlELHdEQUF3RDtRQUN4RCxvREFBb0Q7UUFDcERwQixNQUFNO1FBQ05JLE9BQU9pQixHQUFHO0lBQ1o7SUFFQSxPQUFPakI7QUFDVDtBQUVBLFNBQVNFLFFBQVNGLE1BQU07SUFDdEJBLE9BQU9rQixHQUFHO0lBQ1ZsQixPQUFPZ0IsU0FBUztJQUNoQmhCLE9BQU9pQixHQUFHO0lBQ1ZqQixPQUFPbUIsSUFBSSxDQUFDLFNBQVM7UUFDbkJuQixPQUFPYyxLQUFLO0lBQ2Q7QUFDRjtBQUVBLFNBQVNWLE1BQU9KLE1BQU07SUFDcEJBLE9BQU9nQixTQUFTO0FBQ2xCO0FBRUEsU0FBU0ksVUFBV0MsV0FBVztJQUM3QixNQUFNLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUMsU0FBUyxDQUFDLENBQUMsRUFBRUMsU0FBU3BDLFlBQVksRUFBRSxHQUFHNkI7SUFFaEcsMEJBQTBCO0lBQzFCLE1BQU1RLFVBQVUsT0FBT0QsV0FBVyxXQUFXO1FBQUNBO0tBQU8sR0FBR0E7SUFFeEQsK0NBQStDO0lBQy9DLE1BQU1FLG1CQUFtQiw2QkFBNkJDLGFBQWFBLFdBQVdDLHVCQUF1QixHQUFHLENBQUM7SUFFekcsSUFBSUMsU0FBU1osWUFBWVksTUFBTTtJQUUvQixJQUFJQSxVQUFVVixTQUFTO1FBQ3JCLE1BQU0sSUFBSVcsTUFBTTtJQUNsQjtJQUVBLElBQUlYLFNBQVM7UUFDWFUsU0FBU0gsZ0JBQWdCLENBQUMsY0FBYyxJQUFJckMsS0FBSzBDLFdBQVc7UUFDNURULFFBQVFILE9BQU8sR0FBR0EsUUFBUWEsR0FBRyxDQUFDLENBQUNDO1lBQzdCLE9BQU87Z0JBQ0wsR0FBR0EsSUFBSTtnQkFDUEosUUFBUUssVUFBVUQsS0FBS0osTUFBTTtZQUMvQjtRQUNGO0lBQ0YsT0FBTyxJQUFJWCxVQUFVO1FBQ25CVyxTQUFTSCxnQkFBZ0IsQ0FBQyx1QkFBdUIsSUFBSXJDLEtBQUswQyxXQUFXO1FBQ3JFVCxRQUFRSCxPQUFPLEdBQUdELFNBQVNjLEdBQUcsQ0FBQyxDQUFDQztZQUM5QixPQUFPO2dCQUNMLEdBQUdBLElBQUk7Z0JBQ1BKLFFBQVFLLFVBQVVELEtBQUtKLE1BQU07WUFDL0I7UUFDRjtJQUNGO0lBRUEsSUFBSVQsUUFBUTtRQUNWRSxRQUFRRixNQUFNLEdBQUdBO0lBQ25CO0lBRUEsSUFBSUMsUUFBUTtRQUNWQyxRQUFRRCxNQUFNLEdBQUdBO0lBQ25CO0lBRUFDLFFBQVFhLGtCQUFrQixHQUFHO0lBRTdCLE9BQU9oQyxZQUFZK0IsVUFBVUwsU0FBU1AsU0FBU0M7SUFFL0MsU0FBU1csVUFBV0UsTUFBTTtRQUN4QkEsU0FBU1YsZ0JBQWdCLENBQUNVLE9BQU8sSUFBSUE7UUFFckMsSUFBSTlDLFdBQVc4QyxXQUFXQSxPQUFPQyxPQUFPLENBQUMsZUFBZSxHQUFHO1lBQ3pELE9BQU9EO1FBQ1Q7UUFFQSxJQUFJQSxXQUFXLGFBQWE7WUFDMUIsT0FBTy9DLEtBQUswQyxXQUFXLE1BQU07UUFDL0I7UUFFQSxJQUFJRztRQUVKLEtBQUssTUFBTUksWUFBWWIsUUFBUztZQUM5QixJQUFJO2dCQUNGLE1BQU1jLFVBQVVELGFBQWEsY0FDekI5QixRQUFRZ0MsR0FBRyxLQUFLakQsTUFDaEIrQztnQkFFSkosWUFBWWhELGNBQWNxRCxTQUFTRSxPQUFPLENBQUNMO2dCQUMzQztZQUNGLEVBQUUsT0FBT00sS0FBSztnQkFFWjtZQUNGO1FBQ0Y7UUFFQSxJQUFJLENBQUNSLFdBQVc7WUFDZCxNQUFNLElBQUlKLE1BQU0sQ0FBQywwQ0FBMEMsRUFBRU0sT0FBTyxDQUFDLENBQUM7UUFDeEU7UUFFQSxPQUFPRjtJQUNUO0FBQ0Y7QUFFQVMsT0FBT0MsT0FBTyxHQUFHNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZWN0YXItYWRtaW4tdjEvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdHJhbnNwb3J0LmpzPzU2MTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgY3JlYXRlUmVxdWlyZSB9ID0gcmVxdWlyZSgnbW9kdWxlJylcbmNvbnN0IGdldENhbGxlcnMgPSByZXF1aXJlKCcuL2NhbGxlcicpXG5jb25zdCB7IGpvaW4sIGlzQWJzb2x1dGUsIHNlcCB9ID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBzbGVlcCA9IHJlcXVpcmUoJ2F0b21pYy1zbGVlcCcpXG5jb25zdCBvbkV4aXQgPSByZXF1aXJlKCdvbi1leGl0LWxlYWstZnJlZScpXG5jb25zdCBUaHJlYWRTdHJlYW0gPSByZXF1aXJlKCd0aHJlYWQtc3RyZWFtJylcblxuZnVuY3Rpb24gc2V0dXBPbkV4aXQgKHN0cmVhbSkge1xuICAvLyBUaGlzIGlzIGxlYWsgZnJlZSwgaXQgZG9lcyBub3QgbGVhdmUgZXZlbnQgaGFuZGxlcnNcbiAgb25FeGl0LnJlZ2lzdGVyKHN0cmVhbSwgYXV0b0VuZClcbiAgb25FeGl0LnJlZ2lzdGVyQmVmb3JlRXhpdChzdHJlYW0sIGZsdXNoKVxuXG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgb25FeGl0LnVucmVnaXN0ZXIoc3RyZWFtKVxuICB9KVxufVxuXG5mdW5jdGlvbiBidWlsZFN0cmVhbSAoZmlsZW5hbWUsIHdvcmtlckRhdGEsIHdvcmtlck9wdHMpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFRocmVhZFN0cmVhbSh7XG4gICAgZmlsZW5hbWUsXG4gICAgd29ya2VyRGF0YSxcbiAgICB3b3JrZXJPcHRzXG4gIH0pXG5cbiAgc3RyZWFtLm9uKCdyZWFkeScsIG9uUmVhZHkpXG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcignZXhpdCcsIG9uRXhpdClcbiAgfSlcblxuICBwcm9jZXNzLm9uKCdleGl0Jywgb25FeGl0KVxuXG4gIGZ1bmN0aW9uIG9uUmVhZHkgKCkge1xuICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvbkV4aXQpXG4gICAgc3RyZWFtLnVucmVmKClcblxuICAgIGlmICh3b3JrZXJPcHRzLmF1dG9FbmQgIT09IGZhbHNlKSB7XG4gICAgICBzZXR1cE9uRXhpdChzdHJlYW0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25FeGl0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChzdHJlYW0uY2xvc2VkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc3RyZWFtLmZsdXNoU3luYygpXG4gICAgLy8gQXBwYXJlbnRseSB0aGVyZSBpcyBhIHZlcnkgc3BvcmFkaWMgcmFjZSBjb25kaXRpb25cbiAgICAvLyB0aGF0IGluIGNlcnRhaW4gT1Mgd291bGQgcHJldmVudCB0aGUgbWVzc2FnZXMgdG8gYmUgZmx1c2hlZFxuICAgIC8vIGJlY2F1c2UgdGhlIHRocmVhZCBtaWdodCBub3QgaGF2ZSBiZWVuIGNyZWF0ZWQgc3RpbGwuXG4gICAgLy8gVW5mb3J0dW5hdGVseSB3ZSBuZWVkIHRvIHNsZWVwKDEwMCkgaW4gdGhpcyBjYXNlLlxuICAgIHNsZWVwKDEwMClcbiAgICBzdHJlYW0uZW5kKClcbiAgfVxuXG4gIHJldHVybiBzdHJlYW1cbn1cblxuZnVuY3Rpb24gYXV0b0VuZCAoc3RyZWFtKSB7XG4gIHN0cmVhbS5yZWYoKVxuICBzdHJlYW0uZmx1c2hTeW5jKClcbiAgc3RyZWFtLmVuZCgpXG4gIHN0cmVhbS5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0udW5yZWYoKVxuICB9KVxufVxuXG5mdW5jdGlvbiBmbHVzaCAoc3RyZWFtKSB7XG4gIHN0cmVhbS5mbHVzaFN5bmMoKVxufVxuXG5mdW5jdGlvbiB0cmFuc3BvcnQgKGZ1bGxPcHRpb25zKSB7XG4gIGNvbnN0IHsgcGlwZWxpbmUsIHRhcmdldHMsIGxldmVscywgZGVkdXBlLCBvcHRpb25zID0ge30sIHdvcmtlciA9IHt9LCBjYWxsZXIgPSBnZXRDYWxsZXJzKCkgfSA9IGZ1bGxPcHRpb25zXG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgY29uc3QgY2FsbGVycyA9IHR5cGVvZiBjYWxsZXIgPT09ICdzdHJpbmcnID8gW2NhbGxlcl0gOiBjYWxsZXJcblxuICAvLyBUaGlzIHdpbGwgYmUgZXZlbnR1YWxseSBtb2RpZmllZCBieSBidW5kbGVyc1xuICBjb25zdCBidW5kbGVyT3ZlcnJpZGVzID0gJ19fYnVuZGxlclBhdGhzT3ZlcnJpZGVzJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5fX2J1bmRsZXJQYXRoc092ZXJyaWRlcyA6IHt9XG5cbiAgbGV0IHRhcmdldCA9IGZ1bGxPcHRpb25zLnRhcmdldFxuXG4gIGlmICh0YXJnZXQgJiYgdGFyZ2V0cykge1xuICAgIHRocm93IG5ldyBFcnJvcignb25seSBvbmUgb2YgdGFyZ2V0IG9yIHRhcmdldHMgY2FuIGJlIHNwZWNpZmllZCcpXG4gIH1cblxuICBpZiAodGFyZ2V0cykge1xuICAgIHRhcmdldCA9IGJ1bmRsZXJPdmVycmlkZXNbJ3Bpbm8td29ya2VyJ10gfHwgam9pbihfX2Rpcm5hbWUsICd3b3JrZXIuanMnKVxuICAgIG9wdGlvbnMudGFyZ2V0cyA9IHRhcmdldHMubWFwKChkZXN0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZXN0LFxuICAgICAgICB0YXJnZXQ6IGZpeFRhcmdldChkZXN0LnRhcmdldClcbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2UgaWYgKHBpcGVsaW5lKSB7XG4gICAgdGFyZ2V0ID0gYnVuZGxlck92ZXJyaWRlc1sncGluby1waXBlbGluZS13b3JrZXInXSB8fCBqb2luKF9fZGlybmFtZSwgJ3dvcmtlci1waXBlbGluZS5qcycpXG4gICAgb3B0aW9ucy50YXJnZXRzID0gcGlwZWxpbmUubWFwKChkZXN0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZXN0LFxuICAgICAgICB0YXJnZXQ6IGZpeFRhcmdldChkZXN0LnRhcmdldClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKGxldmVscykge1xuICAgIG9wdGlvbnMubGV2ZWxzID0gbGV2ZWxzXG4gIH1cblxuICBpZiAoZGVkdXBlKSB7XG4gICAgb3B0aW9ucy5kZWR1cGUgPSBkZWR1cGVcbiAgfVxuXG4gIG9wdGlvbnMucGlub1dpbGxTZW5kQ29uZmlnID0gdHJ1ZVxuXG4gIHJldHVybiBidWlsZFN0cmVhbShmaXhUYXJnZXQodGFyZ2V0KSwgb3B0aW9ucywgd29ya2VyKVxuXG4gIGZ1bmN0aW9uIGZpeFRhcmdldCAob3JpZ2luKSB7XG4gICAgb3JpZ2luID0gYnVuZGxlck92ZXJyaWRlc1tvcmlnaW5dIHx8IG9yaWdpblxuXG4gICAgaWYgKGlzQWJzb2x1dGUob3JpZ2luKSB8fCBvcmlnaW4uaW5kZXhPZignZmlsZTovLycpID09PSAwKSB7XG4gICAgICByZXR1cm4gb3JpZ2luXG4gICAgfVxuXG4gICAgaWYgKG9yaWdpbiA9PT0gJ3Bpbm8vZmlsZScpIHtcbiAgICAgIHJldHVybiBqb2luKF9fZGlybmFtZSwgJy4uJywgJ2ZpbGUuanMnKVxuICAgIH1cblxuICAgIGxldCBmaXhUYXJnZXRcblxuICAgIGZvciAoY29uc3QgZmlsZVBhdGggb2YgY2FsbGVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGZpbGVQYXRoID09PSAnbm9kZTpyZXBsJ1xuICAgICAgICAgID8gcHJvY2Vzcy5jd2QoKSArIHNlcFxuICAgICAgICAgIDogZmlsZVBhdGhcblxuICAgICAgICBmaXhUYXJnZXQgPSBjcmVhdGVSZXF1aXJlKGNvbnRleHQpLnJlc29sdmUob3JpZ2luKVxuICAgICAgICBicmVha1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFNpbGVudCBjYXRjaFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZml4VGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBkZXRlcm1pbmUgdHJhbnNwb3J0IHRhcmdldCBmb3IgXCIke29yaWdpbn1cImApXG4gICAgfVxuXG4gICAgcmV0dXJuIGZpeFRhcmdldFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3J0XG4iXSwibmFtZXMiOlsiY3JlYXRlUmVxdWlyZSIsInJlcXVpcmUiLCJnZXRDYWxsZXJzIiwiam9pbiIsImlzQWJzb2x1dGUiLCJzZXAiLCJzbGVlcCIsIm9uRXhpdCIsIlRocmVhZFN0cmVhbSIsInNldHVwT25FeGl0Iiwic3RyZWFtIiwicmVnaXN0ZXIiLCJhdXRvRW5kIiwicmVnaXN0ZXJCZWZvcmVFeGl0IiwiZmx1c2giLCJvbiIsInVucmVnaXN0ZXIiLCJidWlsZFN0cmVhbSIsImZpbGVuYW1lIiwid29ya2VyRGF0YSIsIndvcmtlck9wdHMiLCJvblJlYWR5IiwicHJvY2VzcyIsInJlbW92ZUxpc3RlbmVyIiwidW5yZWYiLCJjbG9zZWQiLCJmbHVzaFN5bmMiLCJlbmQiLCJyZWYiLCJvbmNlIiwidHJhbnNwb3J0IiwiZnVsbE9wdGlvbnMiLCJwaXBlbGluZSIsInRhcmdldHMiLCJsZXZlbHMiLCJkZWR1cGUiLCJvcHRpb25zIiwid29ya2VyIiwiY2FsbGVyIiwiY2FsbGVycyIsImJ1bmRsZXJPdmVycmlkZXMiLCJnbG9iYWxUaGlzIiwiX19idW5kbGVyUGF0aHNPdmVycmlkZXMiLCJ0YXJnZXQiLCJFcnJvciIsIl9fZGlybmFtZSIsIm1hcCIsImRlc3QiLCJmaXhUYXJnZXQiLCJwaW5vV2lsbFNlbmRDb25maWciLCJvcmlnaW4iLCJpbmRleE9mIiwiZmlsZVBhdGgiLCJjb250ZXh0IiwiY3dkIiwicmVzb2x2ZSIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/pino.js":
/*!***********************************!*\
  !*** ./node_modules/pino/pino.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/* eslint no-prototype-builtins: 0 */ const os = __webpack_require__(/*! os */ \"os\");\nconst stdSerializers = __webpack_require__(/*! pino-std-serializers */ \"(rsc)/./node_modules/pino-std-serializers/index.js\");\nconst caller = __webpack_require__(/*! ./lib/caller */ \"(rsc)/./node_modules/pino/lib/caller.js\");\nconst redaction = __webpack_require__(/*! ./lib/redaction */ \"(rsc)/./node_modules/pino/lib/redaction.js\");\nconst time = __webpack_require__(/*! ./lib/time */ \"(rsc)/./node_modules/pino/lib/time.js\");\nconst proto = __webpack_require__(/*! ./lib/proto */ \"(rsc)/./node_modules/pino/lib/proto.js\");\nconst symbols = __webpack_require__(/*! ./lib/symbols */ \"(rsc)/./node_modules/pino/lib/symbols.js\");\nconst { configure } = __webpack_require__(/*! safe-stable-stringify */ \"(rsc)/./node_modules/safe-stable-stringify/index.js\");\nconst { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = __webpack_require__(/*! ./lib/levels */ \"(rsc)/./node_modules/pino/lib/levels.js\");\nconst { DEFAULT_LEVELS, SORTING_ORDER } = __webpack_require__(/*! ./lib/constants */ \"(rsc)/./node_modules/pino/lib/constants.js\");\nconst { createArgsNormalizer, asChindings, buildSafeSonicBoom, buildFormatters, stringify, normalizeDestFileDescriptor, noop } = __webpack_require__(/*! ./lib/tools */ \"(rsc)/./node_modules/pino/lib/tools.js\");\nconst { version } = __webpack_require__(/*! ./lib/meta */ \"(rsc)/./node_modules/pino/lib/meta.js\");\nconst { chindingsSym, redactFmtSym, serializersSym, timeSym, timeSliceIndexSym, streamSym, stringifySym, stringifySafeSym, stringifiersSym, setLevelSym, endSym, formatOptsSym, messageKeySym, errorKeySym, nestedKeySym, mixinSym, levelCompSym, useOnlyCustomLevelsSym, formattersSym, hooksSym, nestedKeyStrSym, mixinMergeStrategySym, msgPrefixSym } = symbols;\nconst { epochTime, nullTime } = time;\nconst { pid } = process;\nconst hostname = os.hostname();\nconst defaultErrorSerializer = stdSerializers.err;\nconst defaultOptions = {\n    level: \"info\",\n    levelComparison: SORTING_ORDER.ASC,\n    levels: DEFAULT_LEVELS,\n    messageKey: \"msg\",\n    errorKey: \"err\",\n    nestedKey: null,\n    enabled: true,\n    base: {\n        pid,\n        hostname\n    },\n    serializers: Object.assign(Object.create(null), {\n        err: defaultErrorSerializer\n    }),\n    formatters: Object.assign(Object.create(null), {\n        bindings (bindings) {\n            return bindings;\n        },\n        level (label, number) {\n            return {\n                level: number\n            };\n        }\n    }),\n    hooks: {\n        logMethod: undefined\n    },\n    timestamp: epochTime,\n    name: undefined,\n    redact: null,\n    customLevels: null,\n    useOnlyCustomLevels: false,\n    depthLimit: 5,\n    edgeLimit: 100\n};\nconst normalize = createArgsNormalizer(defaultOptions);\nconst serializers = Object.assign(Object.create(null), stdSerializers);\nfunction pino(...args) {\n    const instance = {};\n    const { opts, stream } = normalize(instance, caller(), ...args);\n    const { redact, crlf, serializers, timestamp, messageKey, errorKey, nestedKey, base, name, level, customLevels, levelComparison, mixin, mixinMergeStrategy, useOnlyCustomLevels, formatters, hooks, depthLimit, edgeLimit, onChild, msgPrefix } = opts;\n    const stringifySafe = configure({\n        maximumDepth: depthLimit,\n        maximumBreadth: edgeLimit\n    });\n    const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);\n    const stringifyFn = stringify.bind({\n        [stringifySafeSym]: stringifySafe\n    });\n    const stringifiers = redact ? redaction(redact, stringifyFn) : {};\n    const formatOpts = redact ? {\n        stringify: stringifiers[redactFmtSym]\n    } : {\n        stringify: stringifyFn\n    };\n    const end = \"}\" + (crlf ? \"\\r\\n\" : \"\\n\");\n    const coreChindings = asChindings.bind(null, {\n        [chindingsSym]: \"\",\n        [serializersSym]: serializers,\n        [stringifiersSym]: stringifiers,\n        [stringifySym]: stringify,\n        [stringifySafeSym]: stringifySafe,\n        [formattersSym]: allFormatters\n    });\n    let chindings = \"\";\n    if (base !== null) {\n        if (name === undefined) {\n            chindings = coreChindings(base);\n        } else {\n            chindings = coreChindings(Object.assign({}, base, {\n                name\n            }));\n        }\n    }\n    const time = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;\n    const timeSliceIndex = time().indexOf(\":\") + 1;\n    if (useOnlyCustomLevels && !customLevels) throw Error(\"customLevels is required if useOnlyCustomLevels is set true\");\n    if (mixin && typeof mixin !== \"function\") throw Error(`Unknown mixin type \"${typeof mixin}\" - expected \"function\"`);\n    if (msgPrefix && typeof msgPrefix !== \"string\") throw Error(`Unknown msgPrefix type \"${typeof msgPrefix}\" - expected \"string\"`);\n    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);\n    const levels = mappings(customLevels, useOnlyCustomLevels);\n    if (typeof stream.emit === \"function\") {\n        stream.emit(\"message\", {\n            code: \"PINO_CONFIG\",\n            config: {\n                levels,\n                messageKey,\n                errorKey\n            }\n        });\n    }\n    assertLevelComparison(levelComparison);\n    const levelCompFunc = genLevelComparison(levelComparison);\n    Object.assign(instance, {\n        levels,\n        [levelCompSym]: levelCompFunc,\n        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,\n        [streamSym]: stream,\n        [timeSym]: time,\n        [timeSliceIndexSym]: timeSliceIndex,\n        [stringifySym]: stringify,\n        [stringifySafeSym]: stringifySafe,\n        [stringifiersSym]: stringifiers,\n        [endSym]: end,\n        [formatOptsSym]: formatOpts,\n        [messageKeySym]: messageKey,\n        [errorKeySym]: errorKey,\n        [nestedKeySym]: nestedKey,\n        // protect against injection\n        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : \"\",\n        [serializersSym]: serializers,\n        [mixinSym]: mixin,\n        [mixinMergeStrategySym]: mixinMergeStrategy,\n        [chindingsSym]: chindings,\n        [formattersSym]: allFormatters,\n        [hooksSym]: hooks,\n        silent: noop,\n        onChild,\n        [msgPrefixSym]: msgPrefix\n    });\n    Object.setPrototypeOf(instance, proto());\n    genLsCache(instance);\n    instance[setLevelSym](level);\n    return instance;\n}\nmodule.exports = pino;\nmodule.exports.destination = (dest = process.stdout.fd)=>{\n    if (typeof dest === \"object\") {\n        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);\n        return buildSafeSonicBoom(dest);\n    } else {\n        return buildSafeSonicBoom({\n            dest: normalizeDestFileDescriptor(dest),\n            minLength: 0\n        });\n    }\n};\nmodule.exports.transport = __webpack_require__(/*! ./lib/transport */ \"(rsc)/./node_modules/pino/lib/transport.js\");\nmodule.exports.multistream = __webpack_require__(/*! ./lib/multistream */ \"(rsc)/./node_modules/pino/lib/multistream.js\");\nmodule.exports.levels = mappings();\nmodule.exports.stdSerializers = serializers;\nmodule.exports.stdTimeFunctions = Object.assign({}, time);\nmodule.exports.symbols = symbols;\nmodule.exports.version = version;\n// Enables default and name export with TypeScript and Babel\nmodule.exports[\"default\"] = pino;\nmodule.exports.pino = pino;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxHQUFHN0Q7QUFDcEQrRyxzQkFBc0IsR0FBRzdHO0FBQ3pCNkcsc0JBQXNCLEdBQUc3RjtBQUV6Qiw0REFBNEQ7QUFDNUQ2Rix5QkFBc0IsR0FBR2pDO0FBQ3pCaUMsbUJBQW1CLEdBQUdqQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lY3Rhci1hZG1pbi12MS8uL25vZGVfbW9kdWxlcy9waW5vL3Bpbm8uanM/Mjg5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8qIGVzbGludCBuby1wcm90b3R5cGUtYnVpbHRpbnM6IDAgKi9cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKVxuY29uc3Qgc3RkU2VyaWFsaXplcnMgPSByZXF1aXJlKCdwaW5vLXN0ZC1zZXJpYWxpemVycycpXG5jb25zdCBjYWxsZXIgPSByZXF1aXJlKCcuL2xpYi9jYWxsZXInKVxuY29uc3QgcmVkYWN0aW9uID0gcmVxdWlyZSgnLi9saWIvcmVkYWN0aW9uJylcbmNvbnN0IHRpbWUgPSByZXF1aXJlKCcuL2xpYi90aW1lJylcbmNvbnN0IHByb3RvID0gcmVxdWlyZSgnLi9saWIvcHJvdG8nKVxuY29uc3Qgc3ltYm9scyA9IHJlcXVpcmUoJy4vbGliL3N5bWJvbHMnKVxuY29uc3QgeyBjb25maWd1cmUgfSA9IHJlcXVpcmUoJ3NhZmUtc3RhYmxlLXN0cmluZ2lmeScpXG5jb25zdCB7IGFzc2VydERlZmF1bHRMZXZlbEZvdW5kLCBtYXBwaW5ncywgZ2VuTHNDYWNoZSwgZ2VuTGV2ZWxDb21wYXJpc29uLCBhc3NlcnRMZXZlbENvbXBhcmlzb24gfSA9IHJlcXVpcmUoJy4vbGliL2xldmVscycpXG5jb25zdCB7IERFRkFVTFRfTEVWRUxTLCBTT1JUSU5HX09SREVSIH0gPSByZXF1aXJlKCcuL2xpYi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBjcmVhdGVBcmdzTm9ybWFsaXplcixcbiAgYXNDaGluZGluZ3MsXG4gIGJ1aWxkU2FmZVNvbmljQm9vbSxcbiAgYnVpbGRGb3JtYXR0ZXJzLFxuICBzdHJpbmdpZnksXG4gIG5vcm1hbGl6ZURlc3RGaWxlRGVzY3JpcHRvcixcbiAgbm9vcFxufSA9IHJlcXVpcmUoJy4vbGliL3Rvb2xzJylcbmNvbnN0IHsgdmVyc2lvbiB9ID0gcmVxdWlyZSgnLi9saWIvbWV0YScpXG5jb25zdCB7XG4gIGNoaW5kaW5nc1N5bSxcbiAgcmVkYWN0Rm10U3ltLFxuICBzZXJpYWxpemVyc1N5bSxcbiAgdGltZVN5bSxcbiAgdGltZVNsaWNlSW5kZXhTeW0sXG4gIHN0cmVhbVN5bSxcbiAgc3RyaW5naWZ5U3ltLFxuICBzdHJpbmdpZnlTYWZlU3ltLFxuICBzdHJpbmdpZmllcnNTeW0sXG4gIHNldExldmVsU3ltLFxuICBlbmRTeW0sXG4gIGZvcm1hdE9wdHNTeW0sXG4gIG1lc3NhZ2VLZXlTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBuZXN0ZWRLZXlTeW0sXG4gIG1peGluU3ltLFxuICBsZXZlbENvbXBTeW0sXG4gIHVzZU9ubHlDdXN0b21MZXZlbHNTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIGhvb2tzU3ltLFxuICBuZXN0ZWRLZXlTdHJTeW0sXG4gIG1peGluTWVyZ2VTdHJhdGVneVN5bSxcbiAgbXNnUHJlZml4U3ltXG59ID0gc3ltYm9sc1xuY29uc3QgeyBlcG9jaFRpbWUsIG51bGxUaW1lIH0gPSB0aW1lXG5jb25zdCB7IHBpZCB9ID0gcHJvY2Vzc1xuY29uc3QgaG9zdG5hbWUgPSBvcy5ob3N0bmFtZSgpXG5jb25zdCBkZWZhdWx0RXJyb3JTZXJpYWxpemVyID0gc3RkU2VyaWFsaXplcnMuZXJyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgbGV2ZWw6ICdpbmZvJyxcbiAgbGV2ZWxDb21wYXJpc29uOiBTT1JUSU5HX09SREVSLkFTQyxcbiAgbGV2ZWxzOiBERUZBVUxUX0xFVkVMUyxcbiAgbWVzc2FnZUtleTogJ21zZycsXG4gIGVycm9yS2V5OiAnZXJyJyxcbiAgbmVzdGVkS2V5OiBudWxsLFxuICBlbmFibGVkOiB0cnVlLFxuICBiYXNlOiB7IHBpZCwgaG9zdG5hbWUgfSxcbiAgc2VyaWFsaXplcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgIGVycjogZGVmYXVsdEVycm9yU2VyaWFsaXplclxuICB9KSxcbiAgZm9ybWF0dGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgYmluZGluZ3MgKGJpbmRpbmdzKSB7XG4gICAgICByZXR1cm4gYmluZGluZ3NcbiAgICB9LFxuICAgIGxldmVsIChsYWJlbCwgbnVtYmVyKSB7XG4gICAgICByZXR1cm4geyBsZXZlbDogbnVtYmVyIH1cbiAgICB9XG4gIH0pLFxuICBob29rczoge1xuICAgIGxvZ01ldGhvZDogdW5kZWZpbmVkXG4gIH0sXG4gIHRpbWVzdGFtcDogZXBvY2hUaW1lLFxuICBuYW1lOiB1bmRlZmluZWQsXG4gIHJlZGFjdDogbnVsbCxcbiAgY3VzdG9tTGV2ZWxzOiBudWxsLFxuICB1c2VPbmx5Q3VzdG9tTGV2ZWxzOiBmYWxzZSxcbiAgZGVwdGhMaW1pdDogNSxcbiAgZWRnZUxpbWl0OiAxMDBcbn1cblxuY29uc3Qgbm9ybWFsaXplID0gY3JlYXRlQXJnc05vcm1hbGl6ZXIoZGVmYXVsdE9wdGlvbnMpXG5cbmNvbnN0IHNlcmlhbGl6ZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBzdGRTZXJpYWxpemVycylcblxuZnVuY3Rpb24gcGlubyAoLi4uYXJncykge1xuICBjb25zdCBpbnN0YW5jZSA9IHt9XG4gIGNvbnN0IHsgb3B0cywgc3RyZWFtIH0gPSBub3JtYWxpemUoaW5zdGFuY2UsIGNhbGxlcigpLCAuLi5hcmdzKVxuICBjb25zdCB7XG4gICAgcmVkYWN0LFxuICAgIGNybGYsXG4gICAgc2VyaWFsaXplcnMsXG4gICAgdGltZXN0YW1wLFxuICAgIG1lc3NhZ2VLZXksXG4gICAgZXJyb3JLZXksXG4gICAgbmVzdGVkS2V5LFxuICAgIGJhc2UsXG4gICAgbmFtZSxcbiAgICBsZXZlbCxcbiAgICBjdXN0b21MZXZlbHMsXG4gICAgbGV2ZWxDb21wYXJpc29uLFxuICAgIG1peGluLFxuICAgIG1peGluTWVyZ2VTdHJhdGVneSxcbiAgICB1c2VPbmx5Q3VzdG9tTGV2ZWxzLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgaG9va3MsXG4gICAgZGVwdGhMaW1pdCxcbiAgICBlZGdlTGltaXQsXG4gICAgb25DaGlsZCxcbiAgICBtc2dQcmVmaXhcbiAgfSA9IG9wdHNcblxuICBjb25zdCBzdHJpbmdpZnlTYWZlID0gY29uZmlndXJlKHtcbiAgICBtYXhpbXVtRGVwdGg6IGRlcHRoTGltaXQsXG4gICAgbWF4aW11bUJyZWFkdGg6IGVkZ2VMaW1pdFxuICB9KVxuXG4gIGNvbnN0IGFsbEZvcm1hdHRlcnMgPSBidWlsZEZvcm1hdHRlcnMoXG4gICAgZm9ybWF0dGVycy5sZXZlbCxcbiAgICBmb3JtYXR0ZXJzLmJpbmRpbmdzLFxuICAgIGZvcm1hdHRlcnMubG9nXG4gIClcblxuICBjb25zdCBzdHJpbmdpZnlGbiA9IHN0cmluZ2lmeS5iaW5kKHtcbiAgICBbc3RyaW5naWZ5U2FmZVN5bV06IHN0cmluZ2lmeVNhZmVcbiAgfSlcbiAgY29uc3Qgc3RyaW5naWZpZXJzID0gcmVkYWN0ID8gcmVkYWN0aW9uKHJlZGFjdCwgc3RyaW5naWZ5Rm4pIDoge31cbiAgY29uc3QgZm9ybWF0T3B0cyA9IHJlZGFjdFxuICAgID8geyBzdHJpbmdpZnk6IHN0cmluZ2lmaWVyc1tyZWRhY3RGbXRTeW1dIH1cbiAgICA6IHsgc3RyaW5naWZ5OiBzdHJpbmdpZnlGbiB9XG4gIGNvbnN0IGVuZCA9ICd9JyArIChjcmxmID8gJ1xcclxcbicgOiAnXFxuJylcbiAgY29uc3QgY29yZUNoaW5kaW5ncyA9IGFzQ2hpbmRpbmdzLmJpbmQobnVsbCwge1xuICAgIFtjaGluZGluZ3NTeW1dOiAnJyxcbiAgICBbc2VyaWFsaXplcnNTeW1dOiBzZXJpYWxpemVycyxcbiAgICBbc3RyaW5naWZpZXJzU3ltXTogc3RyaW5naWZpZXJzLFxuICAgIFtzdHJpbmdpZnlTeW1dOiBzdHJpbmdpZnksXG4gICAgW3N0cmluZ2lmeVNhZmVTeW1dOiBzdHJpbmdpZnlTYWZlLFxuICAgIFtmb3JtYXR0ZXJzU3ltXTogYWxsRm9ybWF0dGVyc1xuICB9KVxuXG4gIGxldCBjaGluZGluZ3MgPSAnJ1xuICBpZiAoYmFzZSAhPT0gbnVsbCkge1xuICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoaW5kaW5ncyA9IGNvcmVDaGluZGluZ3MoYmFzZSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbmRpbmdzID0gY29yZUNoaW5kaW5ncyhPYmplY3QuYXNzaWduKHt9LCBiYXNlLCB7IG5hbWUgfSkpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdGltZSA9ICh0aW1lc3RhbXAgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICA/IHRpbWVzdGFtcFxuICAgIDogKHRpbWVzdGFtcCA/IGVwb2NoVGltZSA6IG51bGxUaW1lKVxuICBjb25zdCB0aW1lU2xpY2VJbmRleCA9IHRpbWUoKS5pbmRleE9mKCc6JykgKyAxXG5cbiAgaWYgKHVzZU9ubHlDdXN0b21MZXZlbHMgJiYgIWN1c3RvbUxldmVscykgdGhyb3cgRXJyb3IoJ2N1c3RvbUxldmVscyBpcyByZXF1aXJlZCBpZiB1c2VPbmx5Q3VzdG9tTGV2ZWxzIGlzIHNldCB0cnVlJylcbiAgaWYgKG1peGluICYmIHR5cGVvZiBtaXhpbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgRXJyb3IoYFVua25vd24gbWl4aW4gdHlwZSBcIiR7dHlwZW9mIG1peGlufVwiIC0gZXhwZWN0ZWQgXCJmdW5jdGlvblwiYClcbiAgaWYgKG1zZ1ByZWZpeCAmJiB0eXBlb2YgbXNnUHJlZml4ICE9PSAnc3RyaW5nJykgdGhyb3cgRXJyb3IoYFVua25vd24gbXNnUHJlZml4IHR5cGUgXCIke3R5cGVvZiBtc2dQcmVmaXh9XCIgLSBleHBlY3RlZCBcInN0cmluZ1wiYClcblxuICBhc3NlcnREZWZhdWx0TGV2ZWxGb3VuZChsZXZlbCwgY3VzdG9tTGV2ZWxzLCB1c2VPbmx5Q3VzdG9tTGV2ZWxzKVxuICBjb25zdCBsZXZlbHMgPSBtYXBwaW5ncyhjdXN0b21MZXZlbHMsIHVzZU9ubHlDdXN0b21MZXZlbHMpXG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0uZW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0cmVhbS5lbWl0KCdtZXNzYWdlJywgeyBjb2RlOiAnUElOT19DT05GSUcnLCBjb25maWc6IHsgbGV2ZWxzLCBtZXNzYWdlS2V5LCBlcnJvcktleSB9IH0pXG4gIH1cblxuICBhc3NlcnRMZXZlbENvbXBhcmlzb24obGV2ZWxDb21wYXJpc29uKVxuICBjb25zdCBsZXZlbENvbXBGdW5jID0gZ2VuTGV2ZWxDb21wYXJpc29uKGxldmVsQ29tcGFyaXNvbilcblxuICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgbGV2ZWxzLFxuICAgIFtsZXZlbENvbXBTeW1dOiBsZXZlbENvbXBGdW5jLFxuICAgIFt1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltXTogdXNlT25seUN1c3RvbUxldmVscyxcbiAgICBbc3RyZWFtU3ltXTogc3RyZWFtLFxuICAgIFt0aW1lU3ltXTogdGltZSxcbiAgICBbdGltZVNsaWNlSW5kZXhTeW1dOiB0aW1lU2xpY2VJbmRleCxcbiAgICBbc3RyaW5naWZ5U3ltXTogc3RyaW5naWZ5LFxuICAgIFtzdHJpbmdpZnlTYWZlU3ltXTogc3RyaW5naWZ5U2FmZSxcbiAgICBbc3RyaW5naWZpZXJzU3ltXTogc3RyaW5naWZpZXJzLFxuICAgIFtlbmRTeW1dOiBlbmQsXG4gICAgW2Zvcm1hdE9wdHNTeW1dOiBmb3JtYXRPcHRzLFxuICAgIFttZXNzYWdlS2V5U3ltXTogbWVzc2FnZUtleSxcbiAgICBbZXJyb3JLZXlTeW1dOiBlcnJvcktleSxcbiAgICBbbmVzdGVkS2V5U3ltXTogbmVzdGVkS2V5LFxuICAgIC8vIHByb3RlY3QgYWdhaW5zdCBpbmplY3Rpb25cbiAgICBbbmVzdGVkS2V5U3RyU3ltXTogbmVzdGVkS2V5ID8gYCwke0pTT04uc3RyaW5naWZ5KG5lc3RlZEtleSl9OntgIDogJycsXG4gICAgW3NlcmlhbGl6ZXJzU3ltXTogc2VyaWFsaXplcnMsXG4gICAgW21peGluU3ltXTogbWl4aW4sXG4gICAgW21peGluTWVyZ2VTdHJhdGVneVN5bV06IG1peGluTWVyZ2VTdHJhdGVneSxcbiAgICBbY2hpbmRpbmdzU3ltXTogY2hpbmRpbmdzLFxuICAgIFtmb3JtYXR0ZXJzU3ltXTogYWxsRm9ybWF0dGVycyxcbiAgICBbaG9va3NTeW1dOiBob29rcyxcbiAgICBzaWxlbnQ6IG5vb3AsXG4gICAgb25DaGlsZCxcbiAgICBbbXNnUHJlZml4U3ltXTogbXNnUHJlZml4XG4gIH0pXG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBwcm90bygpKVxuXG4gIGdlbkxzQ2FjaGUoaW5zdGFuY2UpXG5cbiAgaW5zdGFuY2Vbc2V0TGV2ZWxTeW1dKGxldmVsKVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpbm9cblxubW9kdWxlLmV4cG9ydHMuZGVzdGluYXRpb24gPSAoZGVzdCA9IHByb2Nlc3Muc3Rkb3V0LmZkKSA9PiB7XG4gIGlmICh0eXBlb2YgZGVzdCA9PT0gJ29iamVjdCcpIHtcbiAgICBkZXN0LmRlc3QgPSBub3JtYWxpemVEZXN0RmlsZURlc2NyaXB0b3IoZGVzdC5kZXN0IHx8IHByb2Nlc3Muc3Rkb3V0LmZkKVxuICAgIHJldHVybiBidWlsZFNhZmVTb25pY0Jvb20oZGVzdClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVpbGRTYWZlU29uaWNCb29tKHsgZGVzdDogbm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yKGRlc3QpLCBtaW5MZW5ndGg6IDAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy50cmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnQnKVxubW9kdWxlLmV4cG9ydHMubXVsdGlzdHJlYW0gPSByZXF1aXJlKCcuL2xpYi9tdWx0aXN0cmVhbScpXG5cbm1vZHVsZS5leHBvcnRzLmxldmVscyA9IG1hcHBpbmdzKClcbm1vZHVsZS5leHBvcnRzLnN0ZFNlcmlhbGl6ZXJzID0gc2VyaWFsaXplcnNcbm1vZHVsZS5leHBvcnRzLnN0ZFRpbWVGdW5jdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aW1lKVxubW9kdWxlLmV4cG9ydHMuc3ltYm9scyA9IHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uXG5cbi8vIEVuYWJsZXMgZGVmYXVsdCBhbmQgbmFtZSBleHBvcnQgd2l0aCBUeXBlU2NyaXB0IGFuZCBCYWJlbFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBpbm9cbm1vZHVsZS5leHBvcnRzLnBpbm8gPSBwaW5vXG4iXSwibmFtZXMiOlsib3MiLCJyZXF1aXJlIiwic3RkU2VyaWFsaXplcnMiLCJjYWxsZXIiLCJyZWRhY3Rpb24iLCJ0aW1lIiwicHJvdG8iLCJzeW1ib2xzIiwiY29uZmlndXJlIiwiYXNzZXJ0RGVmYXVsdExldmVsRm91bmQiLCJtYXBwaW5ncyIsImdlbkxzQ2FjaGUiLCJnZW5MZXZlbENvbXBhcmlzb24iLCJhc3NlcnRMZXZlbENvbXBhcmlzb24iLCJERUZBVUxUX0xFVkVMUyIsIlNPUlRJTkdfT1JERVIiLCJjcmVhdGVBcmdzTm9ybWFsaXplciIsImFzQ2hpbmRpbmdzIiwiYnVpbGRTYWZlU29uaWNCb29tIiwiYnVpbGRGb3JtYXR0ZXJzIiwic3RyaW5naWZ5Iiwibm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yIiwibm9vcCIsInZlcnNpb24iLCJjaGluZGluZ3NTeW0iLCJyZWRhY3RGbXRTeW0iLCJzZXJpYWxpemVyc1N5bSIsInRpbWVTeW0iLCJ0aW1lU2xpY2VJbmRleFN5bSIsInN0cmVhbVN5bSIsInN0cmluZ2lmeVN5bSIsInN0cmluZ2lmeVNhZmVTeW0iLCJzdHJpbmdpZmllcnNTeW0iLCJzZXRMZXZlbFN5bSIsImVuZFN5bSIsImZvcm1hdE9wdHNTeW0iLCJtZXNzYWdlS2V5U3ltIiwiZXJyb3JLZXlTeW0iLCJuZXN0ZWRLZXlTeW0iLCJtaXhpblN5bSIsImxldmVsQ29tcFN5bSIsInVzZU9ubHlDdXN0b21MZXZlbHNTeW0iLCJmb3JtYXR0ZXJzU3ltIiwiaG9va3NTeW0iLCJuZXN0ZWRLZXlTdHJTeW0iLCJtaXhpbk1lcmdlU3RyYXRlZ3lTeW0iLCJtc2dQcmVmaXhTeW0iLCJlcG9jaFRpbWUiLCJudWxsVGltZSIsInBpZCIsInByb2Nlc3MiLCJob3N0bmFtZSIsImRlZmF1bHRFcnJvclNlcmlhbGl6ZXIiLCJlcnIiLCJkZWZhdWx0T3B0aW9ucyIsImxldmVsIiwibGV2ZWxDb21wYXJpc29uIiwiQVNDIiwibGV2ZWxzIiwibWVzc2FnZUtleSIsImVycm9yS2V5IiwibmVzdGVkS2V5IiwiZW5hYmxlZCIsImJhc2UiLCJzZXJpYWxpemVycyIsIk9iamVjdCIsImFzc2lnbiIsImNyZWF0ZSIsImZvcm1hdHRlcnMiLCJiaW5kaW5ncyIsImxhYmVsIiwibnVtYmVyIiwiaG9va3MiLCJsb2dNZXRob2QiLCJ1bmRlZmluZWQiLCJ0aW1lc3RhbXAiLCJuYW1lIiwicmVkYWN0IiwiY3VzdG9tTGV2ZWxzIiwidXNlT25seUN1c3RvbUxldmVscyIsImRlcHRoTGltaXQiLCJlZGdlTGltaXQiLCJub3JtYWxpemUiLCJwaW5vIiwiYXJncyIsImluc3RhbmNlIiwib3B0cyIsInN0cmVhbSIsImNybGYiLCJtaXhpbiIsIm1peGluTWVyZ2VTdHJhdGVneSIsIm9uQ2hpbGQiLCJtc2dQcmVmaXgiLCJzdHJpbmdpZnlTYWZlIiwibWF4aW11bURlcHRoIiwibWF4aW11bUJyZWFkdGgiLCJhbGxGb3JtYXR0ZXJzIiwibG9nIiwic3RyaW5naWZ5Rm4iLCJiaW5kIiwic3RyaW5naWZpZXJzIiwiZm9ybWF0T3B0cyIsImVuZCIsImNvcmVDaGluZGluZ3MiLCJjaGluZGluZ3MiLCJGdW5jdGlvbiIsInRpbWVTbGljZUluZGV4IiwiaW5kZXhPZiIsIkVycm9yIiwiZW1pdCIsImNvZGUiLCJjb25maWciLCJsZXZlbENvbXBGdW5jIiwiSlNPTiIsInNpbGVudCIsInNldFByb3RvdHlwZU9mIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlc3RpbmF0aW9uIiwiZGVzdCIsInN0ZG91dCIsImZkIiwibWluTGVuZ3RoIiwidHJhbnNwb3J0IiwibXVsdGlzdHJlYW0iLCJzdGRUaW1lRnVuY3Rpb25zIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/pino.js\n");

/***/ })

};
;