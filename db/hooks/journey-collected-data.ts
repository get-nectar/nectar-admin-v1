/******************************************************************************
* This file was generated by ZenStack CLI.
******************************************************************************/

/* eslint-disable */
// @ts-nocheck

import type { Prisma, JourneyCollectedData } from "@prisma/client";
import type { UseMutationOptions, UseQueryOptions, UseInfiniteQueryOptions, InfiniteData } from '@tanstack/react-query';
import { getHooksContext } from '@zenstackhq/tanstack-query/runtime-v5/react';
import { useModelQuery, useInfiniteModelQuery, useModelMutation } from '@zenstackhq/tanstack-query/runtime-v5/react';
import type { PickEnumerable, CheckSelect, QueryError, ExtraQueryOptions, ExtraMutationOptions } from '@zenstackhq/tanstack-query/runtime-v5';
import type { PolicyCrudKind } from '@zenstackhq/runtime'
import metadata from './__model_meta';
type DefaultError = QueryError;
import { useSuspenseModelQuery, useSuspenseInfiniteModelQuery } from '@zenstackhq/tanstack-query/runtime-v5/react';
import type { UseSuspenseQueryOptions, UseSuspenseInfiniteQueryOptions } from '@tanstack/react-query';

export function useCreateJourneyCollectedData(options?: Omit<(UseMutationOptions<(JourneyCollectedData | undefined), DefaultError, Prisma.JourneyCollectedDataCreateArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.JourneyCollectedDataCreateArgs, DefaultError, JourneyCollectedData, true>('JourneyCollectedData', 'POST', `${endpoint}/journeyCollectedData/create`, metadata, options, fetch, true)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.JourneyCollectedDataCreateArgs>(
            args: Prisma.SelectSubset<T, Prisma.JourneyCollectedDataCreateArgs>,
            options?: Omit<(UseMutationOptions<(CheckSelect<T, JourneyCollectedData, Prisma.JourneyCollectedDataGetPayload<T>> | undefined), DefaultError, Prisma.SelectSubset<T, Prisma.JourneyCollectedDataCreateArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as (CheckSelect<T, JourneyCollectedData, Prisma.JourneyCollectedDataGetPayload<T>> | undefined);
        },
    };
    return mutation;
}

export function useCreateManyJourneyCollectedData(options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.JourneyCollectedDataCreateManyArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.JourneyCollectedDataCreateManyArgs, DefaultError, Prisma.BatchPayload, false>('JourneyCollectedData', 'POST', `${endpoint}/journeyCollectedData/createMany`, metadata, options, fetch, false)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.JourneyCollectedDataCreateManyArgs>(
            args: Prisma.SelectSubset<T, Prisma.JourneyCollectedDataCreateManyArgs>,
            options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.SelectSubset<T, Prisma.JourneyCollectedDataCreateManyArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as Prisma.BatchPayload;
        },
    };
    return mutation;
}

export function useFindManyJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataFindManyArgs, TQueryFnData = Array<Prisma.JourneyCollectedDataGetPayload<TArgs> & { $optimistic?: boolean }>, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataFindManyArgs>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/findMany`, args, options, fetch);
}

export function useInfiniteFindManyJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataFindManyArgs, TQueryFnData = Array<Prisma.JourneyCollectedDataGetPayload<TArgs>>, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataFindManyArgs>, options?: Omit<UseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>, 'queryKey' | 'initialPageParam'>) {
    options = options ?? { getNextPageParam: () => null };
    const { endpoint, fetch } = getHooksContext();
    return useInfiniteModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/findMany`, args, options, fetch);
}

export function useSuspenseFindManyJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataFindManyArgs, TQueryFnData = Array<Prisma.JourneyCollectedDataGetPayload<TArgs> & { $optimistic?: boolean }>, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataFindManyArgs>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/findMany`, args, options, fetch);
}

export function useSuspenseInfiniteFindManyJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataFindManyArgs, TQueryFnData = Array<Prisma.JourneyCollectedDataGetPayload<TArgs>>, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataFindManyArgs>, options?: Omit<UseSuspenseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>, 'queryKey' | 'initialPageParam'>) {
    options = options ?? { getNextPageParam: () => null };
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseInfiniteModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/findMany`, args, options, fetch);
}

export function useFindUniqueJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataFindUniqueArgs, TQueryFnData = Prisma.JourneyCollectedDataGetPayload<TArgs> & { $optimistic?: boolean }, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataFindUniqueArgs>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/findUnique`, args, options, fetch);
}

export function useSuspenseFindUniqueJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataFindUniqueArgs, TQueryFnData = Prisma.JourneyCollectedDataGetPayload<TArgs> & { $optimistic?: boolean }, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataFindUniqueArgs>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/findUnique`, args, options, fetch);
}

export function useFindFirstJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataFindFirstArgs, TQueryFnData = Prisma.JourneyCollectedDataGetPayload<TArgs> & { $optimistic?: boolean }, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataFindFirstArgs>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/findFirst`, args, options, fetch);
}

export function useSuspenseFindFirstJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataFindFirstArgs, TQueryFnData = Prisma.JourneyCollectedDataGetPayload<TArgs> & { $optimistic?: boolean }, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataFindFirstArgs>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/findFirst`, args, options, fetch);
}

export function useUpdateJourneyCollectedData(options?: Omit<(UseMutationOptions<(JourneyCollectedData | undefined), DefaultError, Prisma.JourneyCollectedDataUpdateArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.JourneyCollectedDataUpdateArgs, DefaultError, JourneyCollectedData, true>('JourneyCollectedData', 'PUT', `${endpoint}/journeyCollectedData/update`, metadata, options, fetch, true)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.JourneyCollectedDataUpdateArgs>(
            args: Prisma.SelectSubset<T, Prisma.JourneyCollectedDataUpdateArgs>,
            options?: Omit<(UseMutationOptions<(CheckSelect<T, JourneyCollectedData, Prisma.JourneyCollectedDataGetPayload<T>> | undefined), DefaultError, Prisma.SelectSubset<T, Prisma.JourneyCollectedDataUpdateArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as (CheckSelect<T, JourneyCollectedData, Prisma.JourneyCollectedDataGetPayload<T>> | undefined);
        },
    };
    return mutation;
}

export function useUpdateManyJourneyCollectedData(options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.JourneyCollectedDataUpdateManyArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.JourneyCollectedDataUpdateManyArgs, DefaultError, Prisma.BatchPayload, false>('JourneyCollectedData', 'PUT', `${endpoint}/journeyCollectedData/updateMany`, metadata, options, fetch, false)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.JourneyCollectedDataUpdateManyArgs>(
            args: Prisma.SelectSubset<T, Prisma.JourneyCollectedDataUpdateManyArgs>,
            options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.SelectSubset<T, Prisma.JourneyCollectedDataUpdateManyArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as Prisma.BatchPayload;
        },
    };
    return mutation;
}

export function useUpsertJourneyCollectedData(options?: Omit<(UseMutationOptions<(JourneyCollectedData | undefined), DefaultError, Prisma.JourneyCollectedDataUpsertArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.JourneyCollectedDataUpsertArgs, DefaultError, JourneyCollectedData, true>('JourneyCollectedData', 'POST', `${endpoint}/journeyCollectedData/upsert`, metadata, options, fetch, true)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.JourneyCollectedDataUpsertArgs>(
            args: Prisma.SelectSubset<T, Prisma.JourneyCollectedDataUpsertArgs>,
            options?: Omit<(UseMutationOptions<(CheckSelect<T, JourneyCollectedData, Prisma.JourneyCollectedDataGetPayload<T>> | undefined), DefaultError, Prisma.SelectSubset<T, Prisma.JourneyCollectedDataUpsertArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as (CheckSelect<T, JourneyCollectedData, Prisma.JourneyCollectedDataGetPayload<T>> | undefined);
        },
    };
    return mutation;
}

export function useDeleteJourneyCollectedData(options?: Omit<(UseMutationOptions<(JourneyCollectedData | undefined), DefaultError, Prisma.JourneyCollectedDataDeleteArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.JourneyCollectedDataDeleteArgs, DefaultError, JourneyCollectedData, true>('JourneyCollectedData', 'DELETE', `${endpoint}/journeyCollectedData/delete`, metadata, options, fetch, true)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.JourneyCollectedDataDeleteArgs>(
            args: Prisma.SelectSubset<T, Prisma.JourneyCollectedDataDeleteArgs>,
            options?: Omit<(UseMutationOptions<(CheckSelect<T, JourneyCollectedData, Prisma.JourneyCollectedDataGetPayload<T>> | undefined), DefaultError, Prisma.SelectSubset<T, Prisma.JourneyCollectedDataDeleteArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as (CheckSelect<T, JourneyCollectedData, Prisma.JourneyCollectedDataGetPayload<T>> | undefined);
        },
    };
    return mutation;
}

export function useDeleteManyJourneyCollectedData(options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.JourneyCollectedDataDeleteManyArgs> & ExtraMutationOptions), 'mutationFn'>) {
    const { endpoint, fetch } = getHooksContext();
    const _mutation =
        useModelMutation<Prisma.JourneyCollectedDataDeleteManyArgs, DefaultError, Prisma.BatchPayload, false>('JourneyCollectedData', 'DELETE', `${endpoint}/journeyCollectedData/deleteMany`, metadata, options, fetch, false)
        ;
    const mutation = {
        ..._mutation,
        mutateAsync: async <T extends Prisma.JourneyCollectedDataDeleteManyArgs>(
            args: Prisma.SelectSubset<T, Prisma.JourneyCollectedDataDeleteManyArgs>,
            options?: Omit<(UseMutationOptions<Prisma.BatchPayload, DefaultError, Prisma.SelectSubset<T, Prisma.JourneyCollectedDataDeleteManyArgs>> & ExtraMutationOptions), 'mutationFn'>
        ) => {
            return (await _mutation.mutateAsync(
                args,
                options as any
            )) as Prisma.BatchPayload;
        },
    };
    return mutation;
}

export function useAggregateJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataAggregateArgs, TQueryFnData = Prisma.GetJourneyCollectedDataAggregateType<TArgs>, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataAggregateArgs>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/aggregate`, args, options, fetch);
}

export function useSuspenseAggregateJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataAggregateArgs, TQueryFnData = Prisma.GetJourneyCollectedDataAggregateType<TArgs>, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataAggregateArgs>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/aggregate`, args, options, fetch);
}

export function useGroupByJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataGroupByArgs, HasSelectOrTake extends Prisma.Or<Prisma.Extends<'skip', Prisma.Keys<TArgs>>, Prisma.Extends<'take', Prisma.Keys<TArgs>>>, OrderByArg extends Prisma.True extends HasSelectOrTake ? { orderBy: Prisma.JourneyCollectedDataGroupByArgs['orderBy'] } : { orderBy?: Prisma.JourneyCollectedDataGroupByArgs['orderBy'] }, OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<TArgs['orderBy']>>>, ByFields extends Prisma.MaybeTupleToUnion<TArgs['by']>, ByValid extends Prisma.Has<ByFields, OrderFields>, HavingFields extends Prisma.GetHavingFields<TArgs['having']>, HavingValid extends Prisma.Has<ByFields, HavingFields>, ByEmpty extends TArgs['by'] extends never[] ? Prisma.True : Prisma.False, InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
        ? never
        : P extends string
        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
        : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`,
        ]
    }[HavingFields]
    : 'take' extends Prisma.Keys<TArgs>
    ? 'orderBy' extends Prisma.Keys<TArgs>
    ? ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields]
    : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<TArgs>
    ? 'orderBy' extends Prisma.Keys<TArgs>
    ? ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields]
    : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields], TQueryFnData = {} extends InputErrors ?
    Array<PickEnumerable<Prisma.JourneyCollectedDataGroupByOutputType, TArgs['by']> &
        {
            [P in ((keyof TArgs) & (keyof Prisma.JourneyCollectedDataGroupByOutputType))]: P extends '_count'
            ? TArgs[P] extends boolean
            ? number
            : Prisma.GetScalarType<TArgs[P], Prisma.JourneyCollectedDataGroupByOutputType[P]>
            : Prisma.GetScalarType<TArgs[P], Prisma.JourneyCollectedDataGroupByOutputType[P]>
        }
    > : InputErrors, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.SubsetIntersection<TArgs, Prisma.JourneyCollectedDataGroupByArgs, OrderByArg> & InputErrors>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/groupBy`, args, options, fetch);
}

export function useSuspenseGroupByJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataGroupByArgs, HasSelectOrTake extends Prisma.Or<Prisma.Extends<'skip', Prisma.Keys<TArgs>>, Prisma.Extends<'take', Prisma.Keys<TArgs>>>, OrderByArg extends Prisma.True extends HasSelectOrTake ? { orderBy: Prisma.JourneyCollectedDataGroupByArgs['orderBy'] } : { orderBy?: Prisma.JourneyCollectedDataGroupByArgs['orderBy'] }, OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<TArgs['orderBy']>>>, ByFields extends Prisma.MaybeTupleToUnion<TArgs['by']>, ByValid extends Prisma.Has<ByFields, OrderFields>, HavingFields extends Prisma.GetHavingFields<TArgs['having']>, HavingValid extends Prisma.Has<ByFields, HavingFields>, ByEmpty extends TArgs['by'] extends never[] ? Prisma.True : Prisma.False, InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
        ? never
        : P extends string
        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
        : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`,
        ]
    }[HavingFields]
    : 'take' extends Prisma.Keys<TArgs>
    ? 'orderBy' extends Prisma.Keys<TArgs>
    ? ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields]
    : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<TArgs>
    ? 'orderBy' extends Prisma.Keys<TArgs>
    ? ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields]
    : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
        ? never
        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
    }[OrderFields], TQueryFnData = {} extends InputErrors ?
    Array<PickEnumerable<Prisma.JourneyCollectedDataGroupByOutputType, TArgs['by']> &
        {
            [P in ((keyof TArgs) & (keyof Prisma.JourneyCollectedDataGroupByOutputType))]: P extends '_count'
            ? TArgs[P] extends boolean
            ? number
            : Prisma.GetScalarType<TArgs[P], Prisma.JourneyCollectedDataGroupByOutputType[P]>
            : Prisma.GetScalarType<TArgs[P], Prisma.JourneyCollectedDataGroupByOutputType[P]>
        }
    > : InputErrors, TData = TQueryFnData, TError = DefaultError>(args: Prisma.SelectSubset<TArgs, Prisma.SubsetIntersection<TArgs, Prisma.JourneyCollectedDataGroupByArgs, OrderByArg> & InputErrors>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/groupBy`, args, options, fetch);
}

export function useCountJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataCountArgs, TQueryFnData = TArgs extends { select: any; } ? TArgs['select'] extends true ? number : Prisma.GetScalarType<TArgs['select'], Prisma.JourneyCollectedDataCountAggregateOutputType> : number, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataCountArgs>, options?: (Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/count`, args, options, fetch);
}

export function useSuspenseCountJourneyCollectedData<TArgs extends Prisma.JourneyCollectedDataCountArgs, TQueryFnData = TArgs extends { select: any; } ? TArgs['select'] extends true ? number : Prisma.GetScalarType<TArgs['select'], Prisma.JourneyCollectedDataCountAggregateOutputType> : number, TData = TQueryFnData, TError = DefaultError>(args?: Prisma.SelectSubset<TArgs, Prisma.JourneyCollectedDataCountArgs>, options?: (Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useSuspenseModelQuery<TQueryFnData, TData, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/count`, args, options, fetch);
}
import type { JourneyCollectedDataType } from '@prisma/client';

export function useCheckJourneyCollectedData<TError = DefaultError>(args: { operation: PolicyCrudKind; where?: { id?: string; journeyId?: string; customFieldId?: string; communityMemberId?: string; collectedDataType?: JourneyCollectedDataType; count?: number }; }, options?: (Omit<UseQueryOptions<boolean, TError, boolean>, 'queryKey'> & ExtraQueryOptions)) {
    const { endpoint, fetch } = getHooksContext();
    return useModelQuery<boolean, boolean, TError>('JourneyCollectedData', `${endpoint}/journeyCollectedData/check`, args, options, fetch);
}
